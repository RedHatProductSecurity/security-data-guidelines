{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Red Hat Security Data","text":"<p>This site contains a set of documents detailing Red Hat's publishing of security data.</p>"},{"location":"cpe/","title":"Identifying Red Hat components using CPEs","text":"<p>Common Platform Enumeration (CPE) is a standardized method of describing and identifying classes of applications, operating systems, and hardware devices present among an enterprise's computing assets.</p> <p>Red Hat uses CPEs to uniquely identify each product and version, following the CPE 2.2 schema.</p>"},{"location":"cpe/#rhel-10-cpes","title":"RHEL 10 CPEs","text":"<p>Starting with  RHEL 10, we will change the way CPEs are assigned to RHEL:</p> <ul> <li>Minor versions will be used in CPEs for mainstream RHEL versions</li> <li>The <code>cpe:/o</code> prefix will be used instead of mixed usage of <code>cpe:/o</code> and <code>cpe:/a</code> for all RHEL variants</li> <li>The channel specifiers are being dropped</li> </ul>"},{"location":"cpe/#minor-version-cpes","title":"Minor Version CPEs","text":"<p>Previously, for RHEL 9 and earlier we assigned generic CPEs like <code>cpe:/o:redhat:enterprise_linux:9</code> for the entire  lifetime of a major release. Minor versions were only reflected in xUS CPEs (e.g., <code>cpe:/a:redhat:rhel_eus:9.2::appstream</code>).</p> <p>Starting with RHEL 10 and all following versions of RHEL, we will use minor versions in mainstream CPEs,  e.g., <code>cpe:/o:redhat:enterprise_linux:10.0</code>, incrementing with each subsequent minor release. This will apply to the  MAIN, GA, and MAIN.EUS variants. This makes it easier to determine which version of RHEL an advisory was released for  without consulting ET product configuration. This also improves our way of tracking releases and which sets of  advisories they shipped. More granular minor versions also allow for the use of version ranges later on, which can be  used to sets of versions (without having to enumerate them all) where the security status such as \"fixed\" is applicable.</p>"},{"location":"cpe/#cpe-type-standardization","title":"CPE Type Standardization","text":"<p>Previously, we used a mix of <code>cpe:/o</code> (operating system) and <code>cpe:/a</code> (application) for different variants of RHEL  (for example, base OS used o and Appstream used a). It is unclear why we decided on this different usage and we've  encountered various issues in our security data files where consumers have to account for both prefixes even though  they identify the same products.</p> <p>Starting with RHEL 10 and all following versions of RHEL, we will standardize on <code>cpe:/o</code> for all RHEL-related components (those shipped under the RHEL product in Errata Tool). EUS CPEs will also transition from <code>cpe:/a</code> to <code>cpe:/o</code>, for example: Base OS: <code>cpe:/o:redhat:enterprise_linux_eus:10.2</code> AppStream: <code>cpe:/o:redhat:enterprise_linux_eus:10.2</code></p>"},{"location":"cpe/#removal-of-channel-specifiers-and-consistent-naming-of-eus-cpes","title":"Removal of channel specifiers and consistent naming of EUS CPEs","text":"<p>CPEs for RHEL 9 and earlier used channel specifiers such as <code>::appstream</code> and <code>::baseos</code> to differentiate between different Errata Tool Variants and pin a specific CPE to a set of RPM repositories. These specifiers were never used externally by any vendor or any of our external documents for any reason other than arbitrary differentiation between groups of content. Starting with RHEL 10, we will drop the use of channel specifiers for RHEL. We will continue using them for layered products to distinguish their base RHEL version if known.</p> <p>Extended streams such as EUS, AUS or TUS always used the name rhel instead of enterprise_linux in the CPE name. Starting with RHEL 10, we will use enterprise_linux only for increased consistency.</p>"},{"location":"csaf-vex/","title":"CSAF Security Advisories and VEX Security Data","text":""},{"location":"csaf-vex/#security-data-overview","title":"Security Data Overview","text":"<p>In the past, Red Hat published security advisory information using Common Vulnerability Reporting Framework (CVRF) and CVE information using the Open Vulnerability and Assessment Language (OVAL) format. As of July 10th, 2024, Red Hat Product Security publishes CSAF files for every single Red Hat Security Advisory (RHSA) and VEX files for every single CVE record that is associated with the Red Hat portfolio in any way.</p> <p>The Common Security Advisory Framework (CSAF) was originally published as an open standard by OASIS Open in November 2022. CSAF files provide a structured, machine-readable way of representing and sharing security advisory information across all software and hardware providers.</p>"},{"location":"csaf-vex/#csaf-security-advisories-overview","title":"CSAF Security Advisories Overview","text":"<p>Red Hat's CSAF security advisory files are always associated with an RHSA. A given security advisory may describe one or more product version(s) and one or more components, depending on the product type and update scope. The RHSA itself can also include updates to address one or more vulnerabilities. Red Hat's CSAF files are publicly available per RHSA here.</p>"},{"location":"csaf-vex/#csaf-vex-overview","title":"CSAF VEX Overview","text":"<p>The CSAF standard acknowledges the need for different use cases and has therefore defined a variety of profiles. Each profile describes the necessary fields and information needed for that specific use case. Red Hat has adopted the Vulnerability Exploitability eXchange (VEX) profile, which is intended to provide the affected state of a vulnerability on a product or component.</p> <p>Red Hat's VEX files are always associated with one CVE and include fix status information for all vulnerable packages and Red Hat products. Red Hat's VEX files are publicly available per CVE here.</p>"},{"location":"csaf-vex/#differences-from-oval","title":"Differences from OVAL","text":"<p>The data that is included in CSAF files differs from that included in OVAL in certain cases:</p> <ul> <li> <p>CSAF files identify a variety of software components, not just RPMs. The identification mechanism used is purl,   which itself contains a type for each identified software component.</p> </li> <li> <p>CSAF files refer to SRPMs only when listed as affected but not yet fixed components. OVAL files contain a   listing of binary RPMs but this listing proved to be difficult to maintain. Until CSAF data is improved to include   consistent lists of binary RPMs, consumers of CSAF data can look up the related SRPM (to be matched with the one in   CSAF files) for a given binary RPM with:   <pre><code># Example lookup for the vim-minimal binary RPM:\n$ rpm -q --qf \"%{SOURCERPM}\\n\" vim-minimal-8.2.2637-21.el9.x86_64\nvim-8.2.2637-21.el9.src.rpm\n</code></pre></p> </li> </ul>"},{"location":"csaf-vex/#document-structure","title":"Document Structure","text":"<p>Although CSAF advisory and VEX files ultimately serve different purposes, both file types meet the CSAF machine-readable standard and use the VEX profile to convey security information. The CSAF standard includes three main sections: document metadata, a product tree and vulnerability metadata. The full document structure can be found here.</p> <p>The following sections break down the information included in CSAF-VEX documents using the VEX file for CVE-2023-20593 as an example.</p>"},{"location":"csaf-vex/#document-metadata","title":"Document Metadata","text":"<p>The <code>document</code> section contains general information about the published document itself including the CVE severity, vendor, published date and revision history.</p> <p>The <code>aggregate_severity.text</code> object displays the general CVE severity:</p> <pre><code>{\n  \"aggregate_severity\": {\n    \"namespace\": \"https://access.redhat.com/security/updates/classification/\",\n    \"text\": \"moderate\"\n  }\n}\n</code></pre> <p>The following objects provide general information about the VEX file itself:</p> <pre><code>{\n  \"category\": \"csaf_vex\",\n  \"csaf_version\": \"2.0\",\n  \"distribution\": {\n    \"text\": \"Copyright \u00a9 Red Hat, Inc. All rights reserved.\",\n    \"tlp\": {\n      \"label\": \"WHITE\",\n      \"url\": \"https://www.first.org/tlp/\"\n    }\n  },\n  \"lang\": \"en\",\n  \"notes\": [\n    {\n      \"category\": \"legal_disclaimer\",\n      \"text\": \"This content is licensed under the Creative Commons Attribution 4.0 International License (https://creativecommons.org/licenses/by/4.0/). If you distribute this content, or a modified version of it, you must provide attribution to Red Hat Inc. and provide a link to the original.\",\n      \"title\": \"Terms of Use\"\n    }\n  ]\n}\n</code></pre> <p>Vendor information is represented in the <code>publisher</code> object:</p> <pre><code>{\n  \"publisher\": {\n    \"category\": \"vendor\",\n    \"contact_details\": \"https://access.redhat.com/security/team/contact/\",\n    \"issuing_authority\": \"Red Hat Product Security is responsible for vulnerability handling across all Red Hat offerings.\",\n    \"name\": \"Red Hat Product Security\",\n    \"namespace\": \"https://www.redhat.com\"\n  }\n}\n</code></pre> <p>CVE ID, CVE publish date and CVE revision history:</p> <ul> <li><code>id</code>: Provides the official CVE ID.</li> <li><code>initial_release_date</code>: Represents the date that the Red Hat first published information on the CVE.</li> <li><code>revision_history</code>: Details any changes made to the CVE information published by Red Hat.</li> </ul> <pre><code>{\n  \"id\": \"CVE-2023-20593\",\n  \"initial_release_date\": \"2023-07-25T06:30:00+00:00\",\n  \"revision_history\": [\n    {\n      \"date\": \"2023-07-25T06:30:00+00:00\",\n      \"number\": \"1\",\n      \"summary\": \"Initial version\"\n    },\n    {\n      \"date\": \"2024-04-18T04:20:20+00:00\",\n      \"number\": \"2\",\n      \"summary\": \"Current version\"\n    },\n    {\n      \"date\": \"2024-09-13T20:58:30+00:00\",\n      \"number\": \"3\",\n      \"summary\": \"Last generated version\"\n    }\n  ],\n  \"status\": \"final\",\n  \"version\": \"3\"\n}\n</code></pre>"},{"location":"csaf-vex/#product-tree","title":"Product Tree","text":"<p>The <code>product_tree</code> section identifies all affected Red Hat software, represents the nested relationship of component to product and provides CPEs or PURLs depending on the affected layer. There are two main objects in the \u201cproduct_tree\u201d object: <code>branches</code> and <code>relationships</code>.</p>"},{"location":"csaf-vex/#branches","title":"Branches","text":"<p>The parent <code>branches</code> object has one child object of the <code>vendor</code> category with the name set to <code>Red Hat</code>. All affected Red Hat products and components will be nested in that <code>branches</code> array. Compressed down, the parent <code>branches</code> object would look like:</p> <pre><code>{\n  \"branches\": [\n    {\n      \"branches\": [],\n      \"category\": \"vendor\",\n      \"name\": \"Red Hat\"\n    }\n  ]\n}\n</code></pre> <p>All nested objects included in the <code>branches</code> object of the <code>vendor</code> category fall into the following subcategories:</p> <ul> <li><code>product_family</code>: Represents a general Red Hat product main stream and includes one or more nested objects of the <code>product_name</code> category.</li> <li><code>product_name</code>: Represents a specific product release and is always nested under the corresponding <code>product_family</code> category.</li> <li><code>product_version</code>: Represents a specific component. When displayed unnested, the component is not fixed yet and will not include a specific version number. Note: This will only be present in VEX files since CSAF files are per RHSA and will only include fixed components.</li> <li><code>architecture</code>: Represents fixed components by their architecture and includes nested   \"product_version\" objects. These \"product_version\" will be fixed and provide the specific version number.</li> </ul>"},{"location":"csaf-vex/#product-family-and-product-name-examples","title":"Product Family and Product Name Examples","text":"<p>The <code>product_family</code> category represents a general Red Hat product stream and includes one or more nested objects of the <code>product_name</code> category that represents an individual release. The <code>product_name</code> object will always include the name of the product, a product ID and a product identification helper in the form of a CPE.</p> <p>In the example below, you can see that the <code>product_family</code> object is for Red Hat Enterprise Linux 6 and nested within is the <code>product_name</code> object Red Hat Enterprise Linux 6 with the CPE \"cpe:/o:redhat:enterprise_linux:6\".</p> <pre><code>{\n  \"branches\": [\n    {\n      \"category\": \"product_name\",\n      \"name\": \"Red Hat Enterprise Linux 6\",\n      \"product\": {\n        \"name\": \"Red Hat Enterprise Linux 6\",\n        \"product_id\": \"red_hat_enterprise_linux_6\",\n        \"product_identification_helper\": {\n          \"cpe\": \"cpe:/o:redhat:enterprise_linux:6\"\n        }\n      }\n    }\n  ],\n  \"category\": \"product_family\",\n  \"name\": \"Red Hat Enterprise Linux 6\"\n}\n</code></pre>"},{"location":"csaf-vex/#unfixed-product-versions-vex-only-examples","title":"Unfixed Product Versions (VEX only) Examples","text":"<p>The <code>product_version</code> category includes information about a specific affected package. The <code>product_version</code> object will always include the name of the component, a product ID and a product identification helper in the form of a PURL. When displayed unnested under an <code>architecture</code> object, the <code>name</code> attribute will not reference a specific version number because these components are unfixed. Again, these unfixed <code>product_version</code> components will only be found in VEX files since CSAF files always represent a released RHSA. The purl identifiers for unfixed content are only available for <code>rpm</code>, <code>oci</code> (container), and <code>rpmmod</code> (modular) purl content type.</p> <p>In the example below, the unfixed kernel component's name is <code>kernel</code> and doesn't include a specific version number or an architecture format.</p> <pre><code>{\n  \"category\": \"product_version\",\n  \"name\": \"kernel\",\n  \"product\": {\n    \"name\": \"kernel\",\n    \"product_id\": \"kernel\",\n    \"product_identification_helper\": {\n      \"purl\": \"pkg:rpm/redhat/kernel?arch=src\"\n    }\n  }\n}\n</code></pre>"},{"location":"csaf-vex/#architecture-and-fixed-product-versions","title":"Architecture and Fixed Product Versions","text":"<p>Similarly to the <code>product_family</code> object, the <code>architecture</code> category represents a specific architecture for packages and includes one or more <code>product_version</code> objects. As before, the <code>product_version</code> category will still include the same information: the name of the component, a product ID and product identification helper in the form of a PURL. However, when <code>product_versions</code> are nested under <code>architecture</code> object, they are fixed components and the <code>name</code> attribute will include a specific version number and the specific architecture format.</p> <p>In the example below, you can see the fixed kernel component's name is <code>kernel-0:3.10.0-693.112.1.el7.src</code> which includes the specific version number <code>0:3.10.0-693.112.1.el7</code> and architecture format <code>.src</code>.</p> <pre><code>{\n  \"branches\": [\n    {\n      \"category\": \"product_version\",\n      \"name\": \"kernel-0:3.10.0-693.112.1.el7.src\",\n      \"product\": {\n        \"name\": \"kernel-0:3.10.0-693.112.1.el7.src\",\n        \"product_id\": \"kernel-0:3.10.0-693.112.1.el7.src\",\n        \"product_identification_helper\": {\n          \"purl\": \"pkg:rpm/redhat/kernel@3.10.0-693.112.1.el7?arch=src\"\n        }\n      }\n    }\n  ],\n  \"category\": \"architecture\",\n  \"name\": \"src\"\n}\n</code></pre>"},{"location":"csaf-vex/#relationships","title":"Relationships","text":"<p>Also included in the <code>product_tree</code> section is a <code>relationships</code> object which is used by Red Hat to help represent layered products. One or more relationship entries will be present for all <code>product_version</code> objects found in the <code>branches</code> object. All of these objects are of the <code>default_component_of</code> category and include the full product name and product ID (a combination of the <code>product_name</code> and the <code>product_version</code>), a reference to the component name and a reference to the product name.</p> <p>Continuing with the previous examples, we know that there should be at least one entry in the <code>relationships</code> object that correlates to the <code>product_version</code> object for kernel. Looking at the VEX file, there are actually four entries for kernel, all which relate to the different <code>product_name</code> objects from before. The below is the specific entry as it relates to Red Hat Enterprise Linux 6.</p> <p>Here you can see that the <code>full_product_name</code> includes a <code>name</code> and a <code>product_id</code> which are the combination of the product, Red Hat Enterprise Linux 6, and the component, kernel. The <code>product_reference</code> will always refer to the component's name while the <code>relates_to_product_reference</code> will refer to the product name.</p> <pre><code>{\n  \"category\": \"default_component_of\",\n  \"full_product_name\": {\n    \"name\": \"kernel as a component of Red Hat Enterprise Linux 6\",\n    \"product_id\": \"red_hat_enterprise_linux_6:kernel\"\n  },\n  \"product_reference\": \"kernel\",\n  \"relates_to_product_reference\": \"red_hat_enterprise_linux_6\"\n}\n</code></pre> <p>For the fixed component <code>kernel-0:3.10.0-693.112.1.el7.src</code>, a relationship entry looks like:</p> <pre><code>{\n  \"category\": \"default_component_of\",\n  \"full_product_name\": {\n    \"name\": \"kernel-0:3.10.0-693.112.1.el7.src as a component of Red Hat Enterprise Linux Server AUS (v. 7.4)\",\n    \"product_id\": \"7Server-7.4.AUS:kernel-0:3.10.0-693.112.1.el7.src\"\n  },\n  \"product_reference\": \"kernel-0:3.10.0-693.112.1.el7.src\",\n  \"relates_to_product_reference\": \"7Server-7.4.AUS\"\n}\n</code></pre>"},{"location":"csaf-vex/#vulnerability-metadata","title":"Vulnerability Metadata","text":"<p>The <code>vulnerabilities</code> section reports vulnerability metadata for the CVE and also contains a <code>product_status</code> object that reports affected status and fix information for any <code>product_id</code> listed in the <code>product_tree</code> and a <code>remediations</code> object.</p>"},{"location":"csaf-vex/#general-cve-information","title":"General CVE Information","text":"<p>Basic CVE information is represented using the following objects: * <code>cve</code>: The official CVE ID. * <code>cwe</code>: Information about the corresponding CWE, include the CWE ID and the name. * <code>discovery_date</code>: The first reported date of the vulnerability. Note: This date can differ from the previously   mentioned <code>initial_release_date</code> if the CVE was coordinated under embargo.</p> <pre><code>{\n  \"cve\": \"CVE-2023-20593\",\n  \"cwe\": {\n    \"id\": \"CWE-1239\",\n    \"name\": \"Improper Zeroization of Hardware Register\"\n  },\n  \"discovery_date\": \"2023-05-31T00:00:00+00:00\"\n}\n</code></pre> <p>Additional CVE information can be found in the <code>notes</code> object:</p> <ul> <li><code>description</code>: This category includes a written description of the CVE.</li> <li><code>summary</code>: This category includes a short summary of the CVE.</li> <li><code>statement</code>: This category includes a statement from Red Hat on the CVE, when applicable (not present in the example).</li> <li><code>general</code>: This category includes a general statement on the applicability of CVSS scores.</li> </ul> <pre><code>{\n  \"notes\": [\n    {\n      \"category\": \"description\",\n      \"text\": \"A flaw was found in hw, in \u201cZen 2\u201d CPUs. This issue may allow an attacker to access sensitive information under specific microarchitectural circumstances.\",\n      \"title\": \"Vulnerability description\"\n    },\n    {\n      \"category\": \"summary\",\n      \"text\": \"hw: amd: Cross-Process Information Leak\",\n      \"title\": \"Vulnerability summary\"\n    },\n    {\n      \"category\": \"general\",\n      \"text\": \"The CVSS score(s) listed for this vulnerability do not reflect the associated product's status, and are included for informational purposes to better understand the severity of this vulnerability.\",\n      \"title\": \"CVSS score applicability\"\n    }\n  ]\n}\n</code></pre> <p>A CVE can have a single CVSS score that is  associated to all products and components in the VEX file or there can be different CVSS score metrics for different subset of products and components (per component Severity and CVSS metadata)</p> <p>All CVSS scores associated with the CVE will have entries included <code>scores</code> object:</p> <ul> <li><code>cvss_v3</code>: Includes attributes for each CVSS base value, the complete CVSS vector string and the version of CVSS that   is used.</li> <li><code>products</code>: Includes all product IDs, both for products and components, that are represented by the scores in the   <code>cvss_v3</code> object.</li> </ul> <pre><code>{\n  \"scores\": [\n    {\n      \"cvss_v3\": {\n        \"attackComplexity\": \"LOW\",\n        \"attackVector\": \"LOCAL\",\n        \"availabilityImpact\": \"NONE\",\n        \"baseScore\": 6.5,\n        \"baseSeverity\": \"MEDIUM\",\n        \"confidentialityImpact\": \"HIGH\",\n        \"integrityImpact\": \"NONE\",\n        \"privilegesRequired\": \"LOW\",\n        \"scope\": \"CHANGED\",\n        \"userInteraction\": \"NONE\",\n        \"vectorString\": \"CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:C/C:H/I:N/A:N\",\n        \"version\": \"3.1\"\n      },\n      \"products\": []\n    }\n  ]\n}\n</code></pre> <p>Similarly to CVSS scores, a CVE can have one severity impact value that represents all products and components in the VEX file or there can be different severity impact values for different subset of products and components (per component Severity and CVSS metadata).</p> <p>All severity impact values with the CVE will have entries included in the <code>threats</code> object:</p> <ul> <li><code>category</code>: The \"impact\" value identifies that the following information is the severity impact value of a CVE.</li> <li><code>details</code>: Reports the appropriate Red Hat Severity Rating   for the associated <code>product_ids</code>.</li> <li><code>product_ids</code>: Includes all product IDs, both for products and components, that have the severity rating in the   <code>details</code> object.</li> </ul> <pre><code>{\n  \"threats\": [\n    {\n      \"category\": \"impact\",\n      \"details\": \"Moderate\",\n      \"product_ids\": []\n    }\n  ]\n}\n</code></pre> <p>Additional CVE resources are described in the <code>references</code> object:</p> <ul> <li><code>category</code>: Either of the type <code>self</code> or <code>external</code>.</li> <li><code>summary</code>: A summary of the provided resource.</li> <li><code>url</code>: A link to the resource.</li> </ul> <pre><code>{\n  \"references\": [\n    {\n      \"category\": \"self\",\n      \"summary\": \"Canonical URL\",\n      \"url\": \"https://access.redhat.com/security/cve/CVE-2023-20593\"\n    },\n    {\n      \"category\": \"external\",\n      \"summary\": \"RHBZ#2217845\",\n      \"url\": \"https://bugzilla.redhat.com/show_bug.cgi?id=2217845\"\n    },\n    {\n      \"category\": \"external\",\n      \"summary\": \"https://www.cve.org/CVERecord?id=CVE-2023-20593\",\n      \"url\": \"https://www.cve.org/CVERecord?id=CVE-2023-20593\"\n    },\n    {\n      \"category\": \"external\",\n      \"summary\": \"https://nvd.nist.gov/vuln/detail/CVE-2023-20593\",\n      \"url\": \"https://nvd.nist.gov/vuln/detail/CVE-2023-20593\"\n    },\n    {\n      \"category\": \"external\",\n      \"summary\": \"https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=522b1d69219d8f083173819fde04f994aa051a98\",\n      \"url\": \"https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=522b1d69219d8f083173819fde04f994aa051a98\"\n    },\n    {\n      \"category\": \"external\",\n      \"summary\": \"https://www.amd.com/en/resources/product-security/bulletin/amd-sb-7008.html\",\n      \"url\": \"https://www.amd.com/en/resources/product-security/bulletin/amd-sb-7008.html\"\n    }\n  ]\n}\n</code></pre>"},{"location":"csaf-vex/#product-fix-status","title":"Product Fix Status","text":"<p>The <code>product_status</code> includes the following fix statuses:</p> <ul> <li><code>fixed</code>: Contains the same fixed component versions and other details (<code>product_tree</code> objects) that are reported fixed for a given CVE</li> <li><code>known_affected</code>: Confirmation that the specific component and product is affected by a particular CVE</li> <li><code>known_not_affected</code>: Confirmation that the specific component and product is not affected by a particular CVE</li> <li><code>under_investigation</code>: Information that the Red Hat Product Security team is verifying the applicability and impact of a specific CVE to the specific component and product</li> </ul> <p>Compressed down, a <code>product_status</code> object that included products of each category, would look like:</p> <pre><code>{\n  \"product_status\": {\n    \"fixed\": [],\n    \"known_affected\": [],\n    \"known_not_affected\": [],\n    \"under_investigation\": []\n  }\n}\n</code></pre> <p>Note: It's important to remember that with VEX files, not every product status will be included, only the categories that have products which fall into those statuses. For CSAF files, the only included status will be the <code>fixed</code> and optionally <code>known_not_affected</code> category if in the released RHSA there are more components and not all were vulnerable to the particular CVE id.</p> <p>Continuing with our previous examples with CVE-2023-20593, the full product ID <code>red_hat_enterprise_linux_6:kernel</code> can be found in the <code>known_not_affected</code> list:</p> <pre><code>{\n  \"known_not_affected\": [\n    \"...\",\n    \"red_hat_enterprise_linux_6:kernel\",\n    \"red_hat_enterprise_linux_6:microcode_ctl\"\n  ]\n}\n</code></pre> <p>Our other full product ID <code>7Server-7.4.AUS:kernel-0:3.10.0-693.112.1.el7.src</code> can be found in the <code>fixed</code> list: <pre><code>{\n  \"fixed\": [\n    \"...\",\n    \"7Server-7.4.AUS:kernel-0:3.10.0-693.112.1.el7.src\",\n    \"7Server-7.4.AUS:kernel-0:3.10.0-693.112.1.el7.x86_64\",\n    \"...\"\n  ]\n}\n</code></pre></p>"},{"location":"csaf-vex/#remediations","title":"Remediations","text":"<p>The <code>remediations</code> object provides additional information about the previously identified product status. The following remediations status are available per <code>product_status</code> category:</p> <p><code>fixed</code></p> <ul> <li><code>vendor_fix</code>: For all the product IDs with a fixed product status there will be a corresponding entry     in the remediations object that correlates each full product ID to the correct RHSAs. The RHSA can be determined by     the <code>url</code> field.<ul> <li><code>details</code>: Advisory specific information </li> <li><code>url</code>: Link to the RHSA</li> </ul> </li> <li><code>workaround</code>: If a mitigation exists, it applies to all components regardless of their fix state.<ul> <li><code>details</code>: The mitigation statement</li> </ul> </li> </ul> <p><code>known_affected</code></p> <ul> <li><code>no_fix_planned</code>: Will include any product IDs with the known affected product status that will not be fixed by Red   Hat, either because it is out of support scope or the engineering team has decided not to fix it for other reasons.<ul> <li><code>details</code>: \"Will not fix\" or \"Out of support scope\"</li> </ul> </li> <li><code>none_available</code>: Will include any product IDs with the known affected product status that are either still reported     affected, meaning a fix is likely in progress, or deferred, which may be fixed at a future date.<ul> <li><code>details</code>: \"Affected\" or \"Deferred\"</li> </ul> </li> <li><code>workaround</code>: If a mitigation exists, it applies to all components regardless of their fix state.<ul> <li><code>details</code>: The mitigation statement</li> </ul> </li> </ul> <p><code>known_not_affected</code>: There are no remediation objects for the known not affected status since it is implicitly assumed that no remediation is needed if the product and component are not affected.</p> <p><code>under_investigation</code>: There are no remediation objects for the under investigation status since it is implicitly assumed that no remediation exist while still under investigation.</p> <p>Note: As with the <code>product_status</code> object, there may not be a <code>remediations</code> entry for every category. Additionally, in VEX files, there may be more than one <code>vendor_fix</code> object if more than one RHSA released fixes for the CVE. In the CSAF files, the only <code>remediations</code> category present will be one <code>vendor_fix</code> object that maps to the RHSA that the CSAF file represents.</p> <p>Following our two previous kernel examples, we can see that for the unfixed kernel component <code>red_hat_enterprise_linux_6:kernel</code> there is no entry in the remediation section. This is expected behavior because it was listed in the <code>known_not_affected</code> product status and therefore no remediation is needed.</p> <p>For our fixed kernel component <code>7Server-7.4.AUS:kernel-0:3.10.0-693.112.1.el7.src</code>, there are two remediation entries. One represents the vendor fix that was released and the other represents that there is a reported mitigation for this CVE.</p> <pre><code>{\n  \"category\": \"vendor_fix\",\n  \"details\": \"For details on how to apply this update, which includes the changes described in this advisory, refer to:\\n\\nhttps://access.redhat.com/articles/11258\\n\\nThe system must be rebooted for this update to take effect.\",\n  \"product_ids\": [\n    \"7Server-7.4.AUS:kernel-0:3.10.0-693.112.1.el7.src\",\n    \"7Server-7.4.AUS:kernel-0:3.10.0-693.112.1.el7.x86_64\",\n    \"...\"\n  ]\n}\n</code></pre> <pre><code>{\n  \"category\": \"workaround\",\n  \"details\": \"Mitigation for this issue is either not available or the currently available options don't meet the Red Hat Product Security criteria comprising ease of use and deployment, applicability to widespread installation base or stability.\",\n  \"product_ids\": [\n    \"...\",\n    \"7Server-7.4.AUS:kernel-0:3.10.0-693.112.1.el7.src\",\n    \"7Server-7.4.AUS:kernel-0:3.10.0-693.112.1.el7.x86_64\",\n    \"...\"\n  ]\n}\n</code></pre>"},{"location":"csaf-vex/#additional-questions-or-concerns","title":"Additional Questions or Concerns","text":"<p>Red Hat is committed to continually improving our security data; any future changes to the data itself or the format of the files are tracked in the Red Hat Security Data Changelog.</p> <p>Please contact Red Hat Product Security with any questions regarding security data at secalert@redhat.com or file an issue in the public SECDATA Jira project.</p>"},{"location":"purl/","title":"Identifying Red Hat components using Package URL","text":"<p>The Package URL (purl) specification has become a widely used proposed standard for identifying and locating software components throughout the open source software community. It is supported by various tools and data formats and provides an easy way for representing package metadata across different contexts and ecosystems.</p> <p>Red Hat uses purl to identify software components in our CSAF advisory and VEX files as well as our SBOM files. We will continue expanding our use of purl across additional security-related metadata files and software solutions in the future as well.</p> <p>To increase the interoperability of all tools processing purl strings, each purl generator must ensure that identical software components are identified with the same purls. Adopting a consistent purl convention across the industry improves collaboration among organizations and simplifies the exchange of (not-just-) security-related metadata.</p> <p>Below, we will cover several areas where the purl specification is overly ambiguous and allows for different ways to interpret the same information, increasing the difficulty of processing purls created by disparate tools. The following sections highlight how Red Hat will use purl for Red Hat produced or hosted software components. We encourage all vendors and open source projects that generate purls that identify Red Hat components to follow these same conventions.</p> <p>Throughout this document, the terms \"(software) component\", \"artifact\", and \"package\" will be used interchangeably to refer to the same concept.</p>"},{"location":"purl/#identifying-rpm-packages","title":"Identifying RPM packages","text":"<p>The <code>rpm</code> purl type identifies, unsurprisingly, an RPM package. When it comes to the naming conventions of a single RPM file, Red Hat uses the NEVRA convention that follows the <code>&lt;name&gt;-&lt;epoch&gt;:&lt;version&gt;-&lt;release&gt;.&lt;architecture&gt;.rpm</code> file name pattern, for example <code>emacs-27.2-9.el9.x86_64.rpm</code>. For more information about RPM packaging conventions, see the RPM Packaging Guide</p> <p>Representing this information in a purl presents a few challenges because the purpose of the purl specification is to not only identify a particular package (the file name already does that) but also the location from where the package can be accessed. The emacs package example above can be represented using the following purl:</p> <pre><code>pkg:rpm/redhat/emacs@27.2-9.el9?arch=x86_64&amp;repository_id=rhel-9-for-x86_64-appstream-rpms\n</code></pre> <p>The namespace value of <code>redhat</code> signifies this as an RPM package produced and distributed by Red Hat. This value also differentiates packages available in Red Hat repositories from those that could potentially share the same name, version, and repository name but were provided by a different vendor.</p> <p>If a purl identifies a Source RPM (SRPM, a package containing source code files that are used to build one or more RPMs containing binary artifacts), the <code>arch</code> qualifier must use the special value <code>src</code>. In the NEVRA file name pattern, SRPM packages use a <code>.src.rpm</code> suffix. Packages that are not architecture-specific must use the special <code>noarch</code> value in the arch qualifier. Binary RPM packages will include a specific architecture as shown in the example above, or will omit the <code>arch</code> qualifier entirely to signify that the identifier applies to all available architectures.</p> <pre><code>pkg:rpm/redhat/emacs@27.2-9.el9?arch=x86_64  # Binary RPM package for the x86_64 architecture\npkg:rpm/redhat/emacs?arch=src  # SRPM package that identifies all available versions of the emacs package\npkg:rpm/redhat/emacs  # Binary RPM package that identifies all available versions and architectures\n</code></pre> <p>An RPM package may also include an epoch number; if not present, it is assumed to be <code>0</code>. In a purl, epoch is not part of the version field, but instead is specified using the <code>epoch</code> qualifier (e.g. <code>epoch=1</code>). If the package version includes a non-zero epoch value, it must be specified using its own epoch qualifier:</p> <pre><code>pkg:rpm/redhat/emacs@27.2-9.el9?epoch=1&amp;arch=src&amp;repository_id=rhel-9-for-x86_64-appstream-rpms\n</code></pre> <p>The <code>rpm</code> purl type suggests the use of the <code>repository_url</code> qualifier to point to the base URL of the RPM repository from where the RPM can be downloaded. We are purposefully not using the <code>repository_url</code> qualifier in Red Hat purls because the base URL can vary depending on whether packages are sourced from Red Hat-hosted repositories (at cdn.redhat.com), local Red Hat Satellite-mirrored repositories, or Cloud provider-hosted repositories. Instead, Red Hat purls use a <code>repository_id</code> qualifier that identifies the repository from which the package can be downloaded using YUM or DNF.</p> <p>The repository ID is a unique value that identifies an RPM repository from where RPM packages can be fetched. If the ID of the repository is the same and the other attributes of the RPM match, such packages even though sourced from varying URLs can be considered the same for the purposes of simple identification. Given a repository ID, you can resolve it to a URL using your chosen base URL and a relative path of that repository that exists in the repository-to-cpe.json mapping file. This file maps repository IDs to both relative URL paths and CPE IDs that represent product versions in all of Red Hat's security data files.</p> <p>Another qualifier defined for the <code>rpm</code> purl type is <code>distro</code>, which is an arbitrary value that describes the Linux distribution that the package is included in. The <code>distro</code> qualifier is not recommended to be used for Red Hat RPMs because its values are not standardized and may, depending on how the value is interpreted, inaccurately identify a package as being specific to a particular version of a distribution even though it may be available in multiple distribution versions.</p>"},{"location":"purl/#identifying-rpm-modules","title":"Identifying RPM modules","text":"<p>RPM modules allow grouping a set of RPMs to represent a single component. Installing, for example, the <code>nodejs</code> module may result in the installation of the <code>c-ares</code> library, the <code>npm</code> package manager, the <code>nodejs</code> runtime, among other RPM packages.</p> <p>RPM modules do not have an existing purl type. In most cases, we want to refer to a specific RPM without a module, and rarely to the RPM module itself. Therefore, we use the RPM type to refer to the specific RPM, and add an <code>rpmmod</code> qualifier to specify the module. For example, the purl for the <code>libecap</code> RPM in the <code>squid:4</code> module available for RHEL 8.6 EUS would be the following:</p> <pre><code>pkg:rpm/redhat/libecap@1.0.1-2.module%2Bel8.1.0%2B4044%2B36416a77?rpmmod=squid:4:8030020200828070549:30b713e6&amp;arch=ppc64le&amp;repository_id=rhel-8-for-x86_64-appstream-eus-rpms__8_DOT_6\n</code></pre> <p>The <code>rpmmod</code> qualifier of the purl is a value that contains the Stream, Version, and Context, delimited by a colon.</p>"},{"location":"purl/#identifying-container-images","title":"Identifying container images","text":"<p>An Open Container Initiative (OCI) artifact is an arbitrary file that adheres to the OCI specification. Here we'll focus on the identification of container images (though similar purl rules should apply to arbitrary OCI artifacts). Container images published in the Red Hat Ecosystem Catalog should be identified using the <code>oci</code> purl type.</p> <p>OCI image artifacts using the Image Manifest specification are identified by a digest value and the URL of the repository from where they can be pulled. If we look at an example container image such as <code>registry.redhat.io/ubi9/ubi:9.3-1610</code>, its digest value for the amd64 architecture is: <code>sha256:8bca3b1be5750aeb94ef1351aa22636a54112f595d11a4d5c777890b80dfd387</code>. In purl, this information is represented as:</p> <pre><code>pkg:oci/ubi@sha256:8bca3b1be5750aeb94ef1351aa22636a54112f595d11a4d5c777890b80dfd387?arch=amd64&amp;repository_url=registry.redhat.io/ubi9/ubi&amp;tag=9.3-1610\n</code></pre> <p>Note that an image with a particular digest value may appear in multiple repositories, so the purl would only differ in the value of the repo namespace in the <code>repository_url</code> qualifier, while representing the same image.</p> <p>Only tags that are unique to a particular container image should be specified in the purl; tags such as latest or 9.3 should not be included because they represent an ever-changing piece of information that may be outdated at the time the purl is used.</p> <p>A purl may also refer to the Image Index, which is a higher-level representation of a set of image manifests. An image index has its own unique digest value:</p> <pre><code>pkg:oci/ubi@sha256:66233eebd72bb5baa25190d4f55e1dc3fff3a9b77186c1f91a0abdb274452072?repository_url=registry.redhat.io/ubi9/ubi&amp;tag=9.3-1610\n</code></pre> <p>The <code>arch</code> qualifier is simply omitted in this purl.</p>"},{"location":"purl/#identifying-maven-packages","title":"Identifying Maven packages","text":"<p>Maven packages distributed by Red Hat follow standard purl-spec rules of the <code>maven</code> purl type:</p> <pre><code>pkg:maven/io.vertx/vertx-web@4.4.8.redhat-00001?type=jar&amp;repository_url=https://maven.repository.redhat.com/ga/\n</code></pre> <p>The version string will contain a <code>redhat-NNNNN</code> suffix to indicate that the component was built from source by Red Hat. If the type qualifier is not set, it is assumed to be <code>jar</code> (as described in the POM documentation). The value in the <code>repository_url</code> should be Red Hat's Maven repository at https://maven.repository.redhat.com/ga/.</p>"},{"location":"purl/#generic-components","title":"Generic components","text":"<p>The purl specification allows for the use of a <code>generic</code> purl type that can be used to identify any software component that does not fit into a specific package ecosystem. Components identified using the <code>generic</code> type normally point to specific artifacts like upstream source code. For example, the purl for the OpenSSL upstream source code repository would be:</p> <pre><code>pkg:generic/openssl@3.0.7?download_url=https://openssl.org/source/openssl-3.0.7.tar.gz&amp;checksum=sha256:83049d042a260e696f62406ac5c08bf706fd84383f945cf21bd61e9ed95c396e\n</code></pre> <p>Each <code>generic</code> purl must include an exact location from where the artifact can be downloaded, and ideally a checksum that corresponds to the artifact.</p> <p>The use of <code>generic</code> purls should be limited to components that are not available in any other purl type.</p>"},{"location":"purl/#additional-notes","title":"Additional Notes","text":"<p>The guidelines highlighted in this document represent an ideal state across all of Red Hat-published security data that we want to achieve in the long term. In some cases, purl identifiers may be missing some of the metadata presented here or not specify it. Please contact Red Hat Product Security or file a Jira issue in the SECDATA project if you find any discrepancies in Red Hat's security data. Feedback on our usage of purl is always welcome and appreciated.</p> <p>Also of note is the purpose of using purls as identifiers versus locators. Some purls may include certain qualifiers that make it easier to identify them but are redundant for the purposes of locating a package. Alternatively, purls that present different sets of qualifiers may still point to the same object. A good analogy for better understanding this concept that is worth quoting here can be found in issue #242 in the purl-spec:</p> <p>Quote</p> <p>Each package type is like a country or state and defines how you can identify and locate a place reasonably uniquely. Uniquely enough that the post can deliver the mail. In a city with well-defined streets and street numbers, you get a precise location with the street name and number and may be an apartment number. In some cases you may want the address for a single person with its name, or the whole household. If someone is off the grid in the bayou or some isolated mountain, crafting a proper address may be more hairy and fuzzy. Worst case I may need GPS coordinates for these edge cases. I may also have many different ways to write an address or a name. Heck, some folks also live in orbit on the ISS and GPS will not work there!</p>"},{"location":"sbom/","title":"Understanding SBOMs","text":"<p>A Software Bill of Materials (SBOM) is at its core a listing of software components for a given deliverable. That deliverable may be a single RPM package, a container image, or an entire product version. There are several use cases where SBOMs are beneficial:</p> <ul> <li> <p>in-depth review of the composition of a particular product for procurement or audit purposes,</p> </li> <li> <p>accurate vulnerability risk assessment when combined with VEX data,</p> </li> <li> <p>or faster incident response when aggregating SBOMs for an entire product portfolio, as well as the pipeline components   that build them.</p> </li> </ul> <p>When talking about inventories of components, it's also important to describe what the current design goals of a comprehensive SBOM are:</p> <ul> <li> <p>Provide a complete and accurate listing of software components and their relationships to each other from a   supply chain perspective:</p> <ul> <li> <p>For each software component, an SBOM must list its provenance. That is, if the (downstream) component is a   redistributed version of an open source project (upstream), the downstream component must be directly linked   to its upstream counterpart. If an upstream component is augmented in a mirrored repository before being used   in a build of a downstream component, this version of the component (also called a midstream component) must   be recorded as a separate package.</p> </li> <li> <p>A manifest must list all components that are included in the final deliverable that can be deployed and run by an   end user. Any software dependencies that are used strictly during the build process must be listed as well, but   separate from the runtime dependencies.</p> </li> </ul> </li> <li> <p>Define an accurate identification of components and products usable across all published security data.</p> </li> </ul> <p>It's equally important to clarify what remains outside the scope of an SBOM:</p> <ul> <li> <p>Provide a component dependency graph: providing dependency relationships between components as part of an   application or an operating system is currently out of scope. This type of information is varied between different   ecosystems, and it would be difficult to express it correctly in product-level SBOMs.   The relationships currently represented are limited to more direct dependencies, such as those between a container   image and the packages it includes, an operating system and its constituent packages, or a package and its   upstream counterpart. We do not include application-level dependencies, like those where a Python package such as   <code>requests</code> depends on another package like   <code>certifi</code>.</p> </li> <li> <p>Inclusion of complete listings of individual files for each component: for each listed component in an SBOM, it is   assumed that the user can fetch it from its indicated location, and inspect the component itself to list out its   files. For example, when downloading a source RPM, the downloaded archive can be unpacked and inspected to acquire   a list of files contained in it.</p> </li> </ul>"},{"location":"sbom/#formats","title":"Formats","text":"<p>The two most widely used SBOM formats are SPDX and CycloneDX. Both offer similar features and data fields, and can be used to represent complex inventories of components, their metadata (such as provenance or licensing), and additional document properties.</p> <p>Most of this document focuses on Red Hat's use of SPDX 2.3 in its published SBOMs. In the future, we may add similar guidelines for CycloneDX and SPDX 3.0.</p>"},{"location":"sbom/#types","title":"Types","text":"<p>Depending on how an SBOM is generated, it will contain varying levels of information. The sections below highlight different viewpoints of when an SBOM is created and what type of data it includes.</p>"},{"location":"sbom/#build-vs-release","title":"Build vs Release","text":"<p>Build-time SBOMs are created during the initial build process of an artifact (for example, when an RPM is created from source files or a container image is built using <code>buildah</code>). These SBOMs document the components used during the build process to produce the final artifact as well as any components used for the build process itself. This SBOM type also aligns with the Build SBOM type from CISA's guidance on Types of SBOM Documents.</p> <p>Release-time SBOMs are created when an artifact is released or published. These SBOMs build upon build-time SBOMs by incorporating additional metadata, such as the repositories or locations where an artifact is published, and associating it with the relevant product information if there is any. Release-time SBOMs reflect the state of the software as it is distributed to end users. This SBOM type should still be considered as a Build SBOM as defined by CISA, but it simply includes additional metadata that is not available during the build process and is added later on. For lack of a better term, we could call these Curated Build SBOMs.</p> <p>Red Hat's publicly available SBOMs are of the release-time type, including details about where an artifact can be located after being released.</p> <p>Example:</p> <ul> <li>Build-time SBOM of the <code>ubi9-micro</code> container image along with all of its installed components (RPMs):   build/ubi9-micro-container-9.4-6.1716471860_amd64</li> <li>Release-time SBOM of the same <code>ubi9-micro</code> container image:   release/ubi9-micro-container-9.4-6.1716471860_amd64</li> </ul> <p>The difference between these two SBOMs is relatively minor; the release-time SBOM contains information on where the container image (identified by two distinct purls) itself is available from:</p> <pre><code>--- sbom/examples/container_image/build/ubi9-micro-container-9.4-6.1716471860_amd64.spdx.json\n+++ sbom/examples/container_image/release/ubi9-micro-container-9.4-6.1716471860_amd64.spdx.json\n@@ -22,12 +22,12 @@\n         {\n           \"referenceCategory\": \"PACKAGE-MANAGER\",\n           \"referenceType\": \"purl\",\n-          \"referenceLocator\": \"pkg:oci/ubi-micro@sha256%3A1c84[...]?arch=amd64\"\n+          \"referenceLocator\": \"pkg:oci/ubi-micro@sha256%3A1c84[...]?arch=amd64&amp;repository_url=registry.access.redhat.com/ubi9/ubi-micro&amp;tag=9.4-6.1716471860\"\n         },\n         {\n           \"referenceCategory\": \"PACKAGE-MANAGER\",\n           \"referenceType\": \"purl\",\n-          \"referenceLocator\": \"pkg:oci/ubi9-micro@sha256%3A1c84[...]?arch=amd64\"\n+          \"referenceLocator\": \"pkg:oci/ubi9-micro@sha256%3A1c84[...]?arch=amd64&amp;repository_url=registry.access.redhat.com/ubi9-micro&amp;tag=9.4-6.1716471860\"\n         }\n       ],\n</code></pre>"},{"location":"sbom/#product-vs-pipeline","title":"Product vs Pipeline","text":"<p>Product SBOMs, as described above in the Build vs Release section, align with the Build SBOM type from CISA's guidance on Types of SBOM Documents.</p> <p>Pipeline SBOMs document the software components that make up systems, tools, and infrastructure (STIs) composing a Pipeline for building our products. These SBOMs may align with Build SBOM type as defined by CISA, or they may align with Source, Analyzed, or even Deployed SBOM types. The difference between these types lies in how the SBOMs are generated, which depends on when during the build and deploy process of a Pipeline STI the SBOM is generated.</p>"},{"location":"sbom/#component-level-vs-product-level","title":"Component-Level vs Product-Level","text":"<p>Component-level SBOMs describe individual components, such as a single RPM package or a container image. They document the full listing of individual components, libraries, and other relevant software that went into building that component. Component-level SBOMs also include provenance metadata for certain components. For example, a component-level SBOM of an RPM will point to the upstream sources that that RPM is based on.</p> <p>Product-level SBOMs describe an entire product and the subset of its components that were built and included in the final product. A product-level SBOM may cover one or more component-level SBOMs, providing a way to connect each release component to its parent product.</p> <p>Example:</p> <ul> <li> <p>Component-level SBOM of the <code>openssl-3.0.7-18.el9_2</code> RPM package:   release/openssl-3.0.7-18.el9_2</p> </li> <li> <p>Product-level SBOM of the <code>openssl-3.0.7-18.el9_2</code> RPM package as included in RHEL 9.2 EUS repositories:   product/rhel-9.2-eus</p> </li> </ul> <p>Note that the root package described by the component-level SBOM, the OpenSSL Source RPM (SRPM), is the only reference present in the product-level SBOM to not duplicate information between the two SBOMs. The purl reference from the SRPM package can be used to discover the component-level SBOM from the product-level SBOM.</p>"},{"location":"sbom/#shallow-vs-complete","title":"Shallow vs Complete","text":"<p>Shallow SBOMs describe only the current layer of components that were used to build a specific artifact. They focus on the immediate components without necessarily documenting their origins. The benefit of this approach is smaller SBOM files, and the ability to make incremental changes in select SBOMs while others remain unchanged when composing multiple SBOMs into a larger set (to describe a product, for example).</p> <p>Complete SBOMs provide a full, in-depth representation of all levels of the build process in a single file. A Complete SBOM includes all component layers and their dependencies, offering a complete view of a product's composition. These types of SBOMs are mostly used for procurement and audit.</p> <p>Red Hat aims to publish Complete SBOMs at https://security.access.redhat.com/data/sbom/ while Shallow SBOMs may be published for individual components such as container images.</p>"},{"location":"sbom/#document-structure","title":"Document Structure","text":"<p>The following snippet shows a minimal SBOM document:</p> SPDX 2.3 <pre><code>{\n  \"spdxVersion\": \"SPDX-2.3\",// (1)!\n  \"dataLicense\": \"CC0-1.0\",// (2)!\n  \"SPDXID\": \"SPDXRef-DOCUMENT\",// (3)!\n  \"creationInfo\": {\n    \"created\": \"2006-08-14T02:34:56Z\",// (4)!\n    \"creators\": [\n      \"Tool: example SPDX document only\",\n      \"Organization: Red Hat\"// (5)!\n    ]\n  },\n  \"name\": \"ubi9-micro-container-9.4-6.1716471860_amd64\",\n  \"documentNamespace\": \"https://www.redhat.com/ubi9-micro-container-9.4-6.1716471860_amd64.spdx.json\",\n  \"packages\": [...],\n  \"files\": [],\n  \"relationships\": [...]\n}\n</code></pre> <ol> <li> <p>SPDX version 2.3 as described at https://spdx.github.io/spdx-spec/v2.3/.</p> </li> <li> <p>The CC0-1.0 license is required by the SPDX specification.</p> </li> <li> <p><code>SPDXID</code>    must be set to <code>SPDXRef-DOCUMENT</code>.</p> </li> <li> <p>UTC timestamps must use the <code>YYYY-MM-DDThh:mm:ssZ</code> format.</p> </li> <li> <p>creationInfo / creators includes the \"Organization: Red Hat\" value.</p> </li> </ol> <p>A more detailed breakdown of some of the fields:</p> <code>creationInfo</code> This field must contain at least the <code>created</code> and <code>creators</code> fields. The timestamp in the <code>created</code> field must be set to an ISO 8601-formatted date and time string using the UTC timezone. The <code>creators</code> field must identify the tool and its version that was used to generate the SBOM file (for example, <code>Tool: SBOMer 1.2.3</code> or even <code>Tool: pkg:github/project-ncl/sbomer@1.0.0.M3</code>). The value <code>Organization: Red Hat</code> included in a separate string. This is required by Red Hat Trusted Profiler Analyser 2 in order to trigger special handling. <code>name</code> This is an arbitrary value that should describe the main artifact described by the SBOM document. This can be a product, a container image, or a specific package. The name should contain a descriptive value for that given artifact along with a version identifier. This field should only serve as a human-readable value and be shown in user interfaces for informational purposes. The metadata of the main package (the one DESCRIBED by the SBOM document) should be used for any automation purposes. Note also that the <code>name</code> value may not be unique to a single SBOM document. <code>documentNamespace</code> <p>This field uniquely identifies the SPDX SBOM document and must be a valid URI, even though that URI does not have to be accessible. Red Hat SBOMs can use one of two possible values:</p> <ul> <li> <p>A URI that is namespaced to a generic Red Hat location: <code>https://www.redhat.com/[DocumentID].spdx.json</code>.   This URI is not accessible and only serves the purpose of identifying the document to its namespace (here,   Red Hat).</p> </li> <li> <p>A URI that is namespaced to <code>access.redhat.com/security/data</code>:  <code>https://security.access.redhat.com/data/sbom/spdx/[DocumentID].spdx.json</code>. This URI is assumed to be accessible   and the identified SBOM can be downloaded from the specified location.</p> </li> </ul> <p>The <code>documentNamespace</code> value has no direct relationship to the <code>name</code> value.</p> <p>The <code>packages</code> and <code>relationships</code> fields are described in depth in the sections below for each respective software content type. The <code>files</code> field is currently unused and will thus either not be present at all, or set to an empty list. All software components in an SBOM are described as packages; all files are assumed to be a part of some package and should thus not be listed on their own in the <code>files</code> field.</p>"},{"location":"sbom/#packages-and-relationships","title":"Packages and Relationships","text":"<p>The purpose of listing out all components as separate package objects ensures we can define meaningful relationships between them. Some packages may for example embed other software components, and other packages may be used only during the build process of creating a set of packages. Differentiating between these different types of components allows us to narrow down the scope of responding to vulnerabilities to only the components that are truly affected by a given vulnerability.</p> <p>The following example shows the structure of a package object for a specific component:</p> SPDX 2.3 <pre><code>{\n  \"SPDXID\": \"SPDXRef-[UUID]\",// (1)!\n  \"name\": \"ubi9-micro-container\",\n  \"versionInfo\": \"9.4-6.1716471860\",\n  \"supplier\": \"Organization: Red Hat\",// (2)!\n  \"downloadLocation\": \"NOASSERTION\",\n  \"licenseConcluded\": \"NOASSERTION\",\n  \"externalRefs\": [...],\n  \"checksums\": [...]\n}\n</code></pre> <ol> <li> <p>A unique identifier of a given component within this document. This value should only be used to associate    relationships to other components described in an SBOM via their relationships.</p> </li> <li> <p>The value <code>Organization: Red Hat</code> must be used for all components that are distributed by Red Hat.</p> </li> </ol> <p>A more detailed breakdown of some of the fields:</p> <code>name</code> The name of the component. This value may differ for different types of package ecosystems. It is recommended to use the <code>name</code> field of the associated purl string for consistent results. <code>versionInfo</code> The version of the component. This value may differ for different types of package ecosystems. It is recommended to use the <code>version</code> field of the associated purl string for consistent results. <code>downloadLocation</code> This field is used to point to the VCS that holds the related source code for this component. In most cases, this field will be set to <code>NOASSERTION</code> because the upstream equivalent of a downstream component is represented with its own package object. <code>licenseConcluded</code> The concluded license of the package, based on the information available during the build. If during the build, this information cannot be determined, the value <code>NOASSERTION</code> should be used. <code>externalRefs</code> At least one of the references must include a Package URL (purl) unless the object is describing a product. Identifying Red Hat components using Package URL documents what purl strings for different types of components should look like. Note that multiple purls may be used for a single package to identify multiple locations from where the package can be accessed. <code>checksums</code> The checksums of the component. The type of checksum used will depend on the type of the component. See below sections for more information."},{"location":"sbom/#container-image","title":"Container Image","text":"<p>A container image can be represented by a package object using the following data:</p> SPDX 2.3 <pre><code>{\n  \"SPDXID\": \"SPDXRef-image-index\",\n  \"name\": \"ubi9-micro-container\",// (1)!\n  \"versionInfo\": \"9.4-6.1716471860\",\n  \"supplier\": \"Organization: Red Hat\",\n  \"downloadLocation\": \"NOASSERTION\",\n  \"licenseDeclared\": \"NOASSERTION\",\n  \"externalRefs\": [\n    {\n      \"referenceCategory\": \"PACKAGE-MANAGER\",\n      \"referenceType\": \"purl\",\n      \"referenceLocator\": \"pkg:oci/ubi-micro@sha256%3A1c8483e0fda0e990175eb9855a5f15e0910d2038dd397d9e2b357630f0321e6d?repository_url=registry.access.redhat.com/ubi9&amp;tag=9.4-6.1716471860\"\n    },\n    {\n      \"referenceCategory\": \"PACKAGE-MANAGER\",\n      \"referenceType\": \"purl\",\n      \"referenceLocator\": \"pkg:oci/ubi9-micro@sha256%3A1c8483e0fda0e990175eb9855a5f15e0910d2038dd397d9e2b357630f0321e6d?repository_url=registry.access.redhat.com&amp;tag=9.4-6.1716471860\"\n    }\n  ],\n  \"checksums\": [\n    {\n      \"algorithm\": \"SHA256\",\n      \"checksumValue\": \"1c8483e0fda0e990175eb9855a5f15e0910d2038dd397d9e2b357630f0321e6d\"\n    }\n  ],\n}\n</code></pre> <ol> <li>The name does not necessarily have to reflect what the container image is named in the container registry;    the name component of the associated purl identifier should be used instead.</li> </ol> <code>checksums</code> The checksum value for a container image refers to the image digest value as defined in the OCI Image Format. purl identifiers A container image may have one or more purls, depending on whether the same image is available in different registries, or different repositories within the same registry. Note that if multiple purls are present, they should only ever differ in their qualifier values, not the main components such as package type, name, or version; multiple package objects should be used if those values differ. license information Licensing information should in most cases be set to <code>NOASSERTION</code> since licensing is set on the software components provided by the container image, and not the image itself. <code>downloadLocation</code> The <code>downloadlocation</code> will never be set; container images don't have their own VCS repos. The location from where the image itself can be downloaded can be acquired from the purl identifier. <p>An SBOM should contain representation of both an Image Index and an architecture-specific image itself. The following is an example of an SPDX relationship between the two:</p> SPDX 2.3 <pre><code>{\n  \"relationships\": [\n    {\n      \"spdxElementId\": \"SPDXRef-DOCUMENT\",\n      \"relationshipType\": \"DESCRIBES\",\n      \"relatedSpdxElement\": \"SPDXRef-image-index\"\n    },\n    {\n      \"spdxElementId\": \"SPDXRef-ubi9-micro-container-ppc64le\",\n      \"relationshipType\": \"VARIANT_OF\",\n      \"relatedSpdxElement\": \"SPDXRef-image-index\"\n    }\n  ]\n}\n</code></pre> <p>An SBOM that represent a container image must also list out all the components included in that image, and create relationships to the architecture-specific image that they are included in:</p> SPDX 2.3 <pre><code>{\n  \"spdxElementId\": \"SPDXRef-ubi9-micro-container-amd64\",\n  \"relationshipType\": \"CONTAINS\",\n  \"relatedSpdxElement\": \"SPDXRef-x86_64-bash\"\n}\n</code></pre> <p>A container image SBOM must also list its parent container image and any container images that were used in the process of building the container image (that is, used in a multi-stage build). As an example, consider the following Dockerfile used to create an image (<code>example-container</code>) by building the <code>foo</code> and <code>bar</code> dependencies using separate images:</p> <pre><code># Dockerfile of example-container\nFROM img-a AS stage1\nRUN make foo\n\nFROM img-b AS stage2\nRUN make bar\n\nFROM ubi9\nCOPY --from=stage1 /work/foo /foo\nCOPY --from=stage2 /work/bar /bar\n</code></pre> <p>The relationship of <code>example-container</code> image to the two container images (<code>stage1</code> and <code>stage2</code>) that were used to build <code>foo</code> and <code>bar</code> so they can be added to the final layers can be represented as:</p> SPDX 2.3 <pre><code>{\n  \"spdxElementId\": \"SPDXRef-stage1-amd64\",\n  \"relationshipType\": \"BUILD_TOOL_OF\",\n  \"relatedSpdxElement\": \"SPDXRef-example-container-container-amd64\"\n},\n{\n  \"spdxElementId\": \"SPDXRef-stage2-amd64\",\n  \"relationshipType\": \"BUILD_TOOL_OF\",\n  \"relatedSpdxElement\": \"SPDXRef-example-container-container-amd64\"\n}\n</code></pre> <p>The parent image of <code>example-container</code> is <code>ubi9</code>. Its relationship to <code>example-container</code> can be represented as:</p> SPDX 2.3 <pre><code>{\n  \"spdxElementId\": \"SPDXRef-example-container-amd64\",\n  \"relationshipType\": \"DESCENDANT_OF\",\n  \"relatedSpdxElement\": \"SPDXRef-ubi9-amd64\"\n}\n</code></pre> <p>Container Images are also linked to one or more upstream sources that were used to build them. An upstream source can be represented by a package object using the following data:</p> SPDX 2.3 <pre><code>{\n  \"SPDXID\": \"SPDXRef-image-index-Source-origin\",\n  \"name\": \"kernel-module-management\",\n  \"versionInfo\": \"d027509b6861d8a9f923cc99dd3e15d9b209e63e\",\n  \"downloadLocation\": \"https://github.com/rh-ecosystem-edge/kernel-module-management#d027509b6861d8a9f923cc99dd3e15d9b209e63e\",\n  \"externalRefs\": [\n    {\n      \"referenceCategory\": \"PACKAGE-MANAGER\",\n      \"referenceType\": \"purl\",\n      \"referenceLocator\": \"pkg:generic/kernel-model-management@d027509b6861d8a9f923cc99dd3e15d9b209e63e?download_url=https://github.com/rh-ecosystem-edge/kernel-module-management#d027509b6861d8a9f923cc99dd3e15d9b209e63e\"\n    }\n  ]\n},\n</code></pre> <p>To associate a set of remote sources with the repository referencing them, use:</p> SPDX 2.3 <pre><code>{\n  \"spdxElementId\": \"SPDXRef-image-index-Source\",\n  \"relationshipType\": \"DEPENDS_ON\",\n  \"relatedSpdxElement\": \"SPDXRef-image-index-Source-origin\"\n},\n</code></pre>"},{"location":"sbom/#rpm","title":"RPM","text":"<p>Before defining what RPM package objects look like, let's also define the specific types of sources that can be involved in the RPM build process:</p> <ul> <li> <p>An upstream source is the original source code as released by the software's primary developers or maintainers.</p> </li> <li> <p>A midstream source is a copy of the upstream code, which may be modified or simply mirrored for distribution   purposes. Midstream sources are optional.</p> </li> <li> <p>A downstream source is a set of sources used to create a source RPM. These are the real build inputs that get   packaged into an SRPM, regardless of whether they originated directly from upstream or came through a midstream   archive. Downstream sources may include distribution-specific patches, build configuration changes, spec files,   and any other files needed to build the final RPM package.</p> </li> </ul> <p>An architecture-specific (downstream) RPM built by Red Hat can be represented by a package object using the following data:</p> SPDX 2.3 <pre><code>{\n  \"SPDXID\": \"SPDXRef-aarch64-openssl-libs\",\n  \"name\": \"openssl-libs\",\n  \"versionInfo\": \"3.0.7-18.el9_2\",\n  \"supplier\": \"Organization: Red Hat\",\n  \"downloadLocation\": \"NOASSERTION\",\n  \"packageFileName\": \"openssl-libs-3.0.7-18.el9_2.aarch64.rpm\",\n  \"licenseConcluded\": \"Apache-2.0\",\n  \"externalRefs\": [\n    {\n      \"referenceCategory\": \"PACKAGE-MANAGER\",\n      \"referenceType\": \"purl\",\n      \"referenceLocator\": \"pkg:rpm/redhat/openssl-libs@3.0.7-18.el9_2?arch=aarch64&amp;repository_id=rhel-9-for-aarch64-baseos-eus-rpms\"\n    },\n    {\n      \"referenceCategory\": \"PACKAGE-MANAGER\",\n      \"referenceType\": \"purl\",\n      \"referenceLocator\": \"pkg:rpm/redhat/openssl-libs@3.0.7-18.el9_2?arch=aarch64&amp;repository_id=rhel-9-for-aarch64-baseos-aus-rpms\"\n    },\n    {\n      \"referenceCategory\": \"PACKAGE-MANAGER\",\n      \"referenceType\": \"purl\",\n      \"referenceLocator\": \"pkg:rpm/redhat/openssl-libs@3.0.7-18.el9_2?arch=aarch64&amp;repository_id=rhel-9-for-aarch64-baseos-e4s-rpms\"\n    }\n  ],\n  \"checksums\": [\n    {\n      \"algorithm\": \"SHA256\",\n      \"checksumValue\": \"cae5941219fd64e75c2b29509c6fe712bef77181a586702275a46a5e812d4dd4\"\n    }\n  ],\n  \"annotations\": [\n    {\n      \"annotationType\": \"OTHER\",\n      \"annotator\": \"Tool: example SPDX document only\",\n      \"annotationDate\": \"2006-08-14T02:34:56+00:00\",\n      \"comment\": \"sigmd5: 4cc665dd3173c8952184293588f9ee46\"\n    }\n  ]\n}\n</code></pre> <code>downloadLocation</code> The <code>downloadlocation</code> will never be set; container images don't have their own VCS repos. The location from where the image itself can be downloaded can be acquired from the purl identifier. purl identifiers A single RPM package may be available from multiple DNF/Yum repositories, in which case it will include a purl identifier for each repository it can be downloaded from. Note that if multiple purls are present, they should only ever differ in their qualifier values, not the main components such as package type, name, or version; multiple package objects should be used if those values differ. <code>checksums</code> Minimally, the list of checksums must include the SHA256 checksum of the RPM file or source archive itself. All other checksums should be specified as annotations (see below). <code>annotations</code> A list of annotations may provide additional information that is specific to the RPM format. In the example above, two checksum values are included: - The MD5 checksum of the signed header of the RPM package is included. - The SHA256 checksum of the RPM header (this value does not change when an RPM is signed; unlike the file SHA256 \\   checksum used in <code>checksums</code>). <p>Each set of architecture-specific RPMs also has an associated source RPM (SRPM) that bundles all the source code that was used to build those RPMs. SRPMs should be represented as a separate package object in an SBOM, and their relationship to architecture-specific RPMs can be represented with:</p> SPDX 2.3 <pre><code>{\n  \"spdxElementId\": \"SPDXRef-ppc64le-openssl-libs\",\n  \"relationshipType\": \"GENERATED_FROM\",\n  \"relatedSpdxElement\": \"SPDXRef-SRPM\"\n}\n</code></pre> <p>SRPMs are also linked to one or more upstream sources that were used to build the downstream RPMs. An upstream source can be represented by a package object using the following data:</p> SPDX 2.3 <pre><code>{\n  \"SPDXID\": \"SPDXRef-Source0-origin\",\n  \"name\": \"openssl\",\n  \"versionInfo\": \"3.0.7\",\n  \"downloadLocation\": \"https://openssl.org/source/openssl-3.0.7.tar.gz\",\n  \"homepage\": \"https://openssl-library.org/\",\n  \"packageFileName\": \"openssl-3.0.7.tar.gz\",\n  \"checksums\": [\n    {\n      \"algorithm\": \"SHA256\",\n      \"checksumValue\": \"83049d042a260e696f62406ac5c08bf706fd84383f945cf21bd61e9ed95c396e\"\n    }\n  ],\n  \"externalRefs\": [\n    {\n      \"referenceCategory\": \"PACKAGE-MANAGER\",\n      \"referenceType\": \"purl\",\n      \"referenceLocator\": \"pkg:generic/openssl@3.0.7?download_url=https://openssl.org/source/openssl-3.0.7.tar.gz&amp;checksum=sha256:83049d042a260e696f62406ac5c08bf706fd84383f945cf21bd61e9ed95c396e\"\n    }\n  ]\n}\n</code></pre> purl identifiers In cases where the upstream source is a package in a registry such as PyPI or NPM, the purl identifier will use the respective package type. For components that are distributed as standalone bundles (such as OpenSSL in the example above), <code>generic</code> purls should be used with an exact download URL from where a specific bundle of source code was fetched from, including a checksum (which should also be specified in the <code>checksums</code> field). <p>To associate a set of source archives with the SRPM that includes them, use:</p> SPDX 2.3 <pre><code>{\n  \"spdxElementId\": \"SPDXRef-SRPM\",\n  \"relationshipType\": \"CONTAINS\",\n  \"relatedSpdxElement\": \"SPDXRef-Source0\"\n}\n</code></pre> <p>Optionally, an upstream source may be mirrored in a different repository where the source is modified in a way that makes it consumable by the downstream distributor. This is referred to as a midstream source. The package object for the midstream source looks identical to an upstream package, but with different download location and purl identifier.</p> <p>The relationship between an upstream source and a midstream source can be represented with:</p> SPDX 2.3 <pre><code>{\n  \"spdxElementId\": \"SPDXRef-Midstream0\",\n  \"relationshipType\": \"GENERATED_FROM\",\n  \"relatedSpdxElement\": \"SPDXRef-Source0\"\n}\n</code></pre> <p>The complete diagram of the relationships between the various types of sources in an SBOM might look like this:</p> <pre><code>graph TD\n    A[\"https://openssl.org/source/openssl-3.0.7.tar.gz\"]\n    B[\"https://github.com/(RH openssl midstream repo)/archive/refs/tags/3.0.7.tar.gz\"]\n    C[\"SRPM: openssl 3.0.7-18.el9_2.src\"]\n    D[\"RPM: openssl 3.0.7-18.el9_2.aarch64\"]\n    C --&gt;|CONTAINS| B\n    B --&gt;|GENERATED_FROM| A\n    D --&gt;|GENERATED_FROM| C</code></pre>"},{"location":"sbom/#product","title":"Product","text":"<p>Individual components such as packages and container images are almost always provided as part of a specific product. Products represent a bundle of components that can be purchased, has a life cycle (example) defined for it, and a support policy.</p> <p>If one or more components described in a given SBOM are being provided as part of a product, that product should be represented with its own package object:</p> SPDX 2.3 <pre><code>{\n  \"SPDXID\": \"SPDXRef-RHEL-9.2-EUS\",\n  \"name\": \"Red Hat Enterprise Linux\",\n  \"versionInfo\": \"9.2 EUS\",\n  \"supplier\": \"Organization: Red Hat\",\n  \"downloadLocation\": \"NOASSERTION\",// (1)!\n  \"licenseConcluded\": \"NOASSERTION\",// (2)!\n  \"externalRefs\": [\n    {\n      \"referenceCategory\": \"SECURITY\",\n      \"referenceLocator\": \"cpe:/a:redhat:rhel_eus:9.2::baseos\",\n      \"referenceType\": \"cpe22Type\"\n    }\n  ]\n}\n</code></pre> <ol> <li> <p>Not used because this product component is not specific enough to an architecture or ISO variant (for example,    workstation vs server) for there to be an exact download location.</p> </li> <li> <p>Not set, only components have licenses.</p> </li> </ol> <code>name</code> This field must contain a human-readable name of the product. <code>versionInfo</code> This field must contain the most granular version of the product, for which the SBOM was generated. <code>externalRefs</code> External references must contain a unique identifier of the product. Red Hat uses CPE IDs to identify products. A given product may have one or more of these identifiers, covering all possible variants of a single product version. <p>A relationship between a component and the product it is a part of can be represented as:</p> SPDX 2.3 <pre><code>{\n  \"spdxElementId\": \"SPDXRef-SRPM-1\",\n  \"relationshipType\": \"PACKAGE_OF\",\n  \"relatedSpdxElement\": \"SPDXRef-RHEL-9.2-EUS\"\n}\n</code></pre>"},{"location":"sbom/#additional-notes","title":"Additional Notes","text":"<p>The guidelines highlighted in this document represent an ideal state across all of Red Hat-published security data that we want to achieve in the long term. In some SBOMs, components may be missing their provenance data or their license expressions may not be accurate. Please contact Red Hat Product Security or file a Jira issue in the SECDATA project if you find any discrepancies in Red Hat's security data. Feedback on our SBOM design and publishing is always welcome and appreciated.</p>"},{"location":"scanning-vendors/","title":"Technical Guidance for Vulnerability Scanning Vendors","text":""},{"location":"scanning-vendors/#introduction","title":"Introduction","text":"<p>This article covers the basic principles for how scanning vendors should use Red Hat security data to accurately report  on vulnerabilities, specifically for Red Hat containers images. </p>"},{"location":"scanning-vendors/#process-overview","title":"Process Overview","text":"<p>Red Hat security data reports vulnerability information per product and component combination. In order to accurately report  vulnerability information against Red Hat products using CSAF advisories and VEX data, vendors should follow these process steps: </p> <ol> <li>Component Identification: Determine what components are included in the scanned container, including information  about the container itself and represent them using purls.</li> <li>Product Identification: Determine what product the components are correlated to using container metadata using  repositories and represent them with CPEs.</li> <li>Product and Component Matching: Identify product/component pairs with product IDs by matching components to purls  and products to CPEs.</li> <li>Determine Vulnerability Information: Find vulnerability information such as severity, affectedness information  and any available security fixes by using the product/component product IDs.</li> </ol> <p>The rest of this document will cover each of these topics in more detail and include relevant examples from the following images: </p> <p>Repository: registry.redhat.io/rhel9/python-312 Tag: 1-25 </p> <p>Repository: registry.redhat.io/openshift4/ose-console-rhel9 Tag: v4.16.0-202409181705.p0.g0b1616c.assembly.stream.el9</p>"},{"location":"scanning-vendors/#component-identification","title":"Component Identification","text":"<p>The Package URL (purl) specification has become a widely used standard for identifying and locating software  components throughout the open source software community.</p> <p>Red Hat uses purl to identify software components, including RPMs, RPM modules and container first content, in our  CSAF advisory and VEX files as well as our SBOM files. Detailed information about Red Hat purls can be found  here.</p>"},{"location":"scanning-vendors/#rpms-and-rpm-modules","title":"RPMs and RPM modules","text":"<p>An RPM package is a file format used by the Red Hat Package Manager (RPM) system for software distribution and management,  which package consists of an archive of files and metadata used to install and erase these files.</p> <p>There are two types of RPM packages: source RPMs, which contain source code and a spec file and binary RPMs, which are the files built from source packages and patches. </p> <p>Additionally, an RPM module is a set of RPM packages that represent a component and are usually installed together.  Starting from RHEL 10, there will be no more RPM modules.</p> <p>SRPMS, RPMs and RPM modules are represented in CSAF advisories and VEX data using the <code>rpm</code> purl type. More detailed information about RPM purl usage can be found here.</p>"},{"location":"scanning-vendors/#binary-rpms","title":"Binary RPMs","text":"<p>Both binary RPMs and RPM modules installed in a container image can be discovered using the <code>rpm -qa</code> command from within  the container image. <pre><code># Example return of RPM query\n$ rpm -qa --qf '%{NAME} %{EPOCHNUM} %{VERSION} %{RELEASE} %{ARCH}\\n'\n\nlibgcc 0 11.3.1 4.3.el9 x86_64\nsubscription-manager-rhsm-certificates 0 20220623 1.el9 noarch\nsetup 0 2.13.7 9.el9 noarch\nfilesystem 0 3.16 2.el9 x86_64\nbasesystem 0 11 13.el9 noarch\n</code></pre></p> <p>Using this information, we can format a purl for the libgcc component.  <pre><code># Example of binary RPM purl using name, version and architecture\n\npkg:rpm/redhat/libgcc@11.3.1-4.3.el9?arch=x86_64\n</code></pre></p>"},{"location":"scanning-vendors/#srpms","title":"SRPMs","text":"<p>Additionally, SRPMs can be discovered from a binary RPM by using the following command from within the container image.</p> <pre><code># Example return of SRPM query\n$ rpm -q --qf '%{SOURCERPM}\\n' libgcc  \n\ngcc-11.3.1-4.3.el9.src.rpm\n</code></pre> <p>The gcc source component can be represented using the following purl. <pre><code># Example of SRPM purl using name, version and architecture \n\npkg:rpm/redhat/gcc@11.3.1-4.3.el9?arch=src\n</code></pre></p>"},{"location":"scanning-vendors/#rpm-modules","title":"RPM modules","text":"<p>RPM modules can be discovered using the same command seen in the Binary RPMs section, but will be represented slightly  differently in purl format. </p> <p>The following is an example of how the nodejs-docs rpm from the nodejs module is represented in a purl  <pre><code># Example of RPM module purl using name, version, rpmmod qualifier and architecture \n\npkg:rpm/redhat/nodejs-docs@20.16.0-1.module%2Bel9.4.0%2B22197%2b9e60f127?arch=x86_64&amp;epoch=1&amp;rpmmod=nodejs:20:9040020240807145403:rhel9\n</code></pre></p>"},{"location":"scanning-vendors/#container-metadata-and-container-first-content","title":"Container metadata and container first content","text":"<p>Container images frequently include non-RPM packages, often referred to as container first content. Non-RPM packages  that exist in a container image are reported in security data (CVE pages, CSAF/VEX files) on the container  level instead of the package name.</p> <p>Containers are represented with the <code>oci</code> purl type. More detailed information about OCI purl usage can be found here.</p>"},{"location":"scanning-vendors/#container-name-and-pullspec","title":"Container name and pullspec","text":"<p>From within the OpenShift cluster, you can determine the container pullspecs in a given namespace using the following command. <pre><code> # oc get pod command\n\n $ oc get pod &lt;pod-name&gt; -o jsonpath=' {.spec.containers[*].name}' -n &lt;namespace&gt;\n</code></pre></p>"},{"location":"scanning-vendors/#container-tag-openshift-version-and-other-metadata","title":"Container tag, Openshift version and other metadata","text":"<p>If you already have the pullspec for the container image you are scanning, you can use the following method to  determine additional container metadata. <pre><code># Example using oc image command with the pullspec\n$ oc image info registry.redhat.io/openshift4/ose-console-rhel9@sha256:4a6ea66336fc875f84f24bf9ebfdf5b7c166eb19dd68d88ec6035392162b4c5a\n\nName:        registry.redhat.io/openshift4/ose-console-rhel9@sha256:4a6ea66336fc875f84f24bf9ebfdf5b7c166eb19dd68d88ec6035392162b4c5a\nMedia Type:  application/vnd.docker.distribution.manifest.v2+json\nCreated:     1y ago\nImage Size:  210.8MB in 4 layers\nLayers:      78.17MB sha256:ca1636478fe5b8e2a56600e24d6759147feb15020824334f4a798c1cb6ed58e2\n             47.67MB sha256:24f5353c85f58ec262052e1b10214db36acc498ffe45b3ffd8ac3af8d7eec61c\n             10.47MB sha256:0cb75215d50fe354485561a528b8b0239ac54a68fd3a6b670f3654ba54b24ec0\n             74.45MB sha256:356fed97f66574bd12d47f144a3bf53471b52b11e99b79a3701da0f9f45eafe9\nOS:          linux\nArch:        amd64\nCommand:     /opt/bridge/bin/bridge --public-dir=/opt/bridge/static\nWorking Dir: /\nUser:        1001\nEnvironment: PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\n             container=oci\n             GODEBUG=x509ignoreCN=0,madvdontneed=1\n             __doozer=merge\n             BUILD_RELEASE=202409181705.p0.g0b1616c.assembly.stream.el9\n             BUILD_VERSION=v4.16.0\n             OS_GIT_MAJOR=4\n             OS_GIT_MINOR=16\n             OS_GIT_PATCH=0\n             OS_GIT_TREE_STATE=clean\n             OS_GIT_VERSION=4.16.0-202409181705.p0.g0b1616c.assembly.stream.el9-0b1616c\n             SOURCE_GIT_TREE_STATE=clean\n             __doozer_group=openshift-4.16\n             __doozer_key=openshift-enterprise-console\n             __doozer_version=v4.16.0\n             OS_GIT_COMMIT=0b1616c\n             SOURCE_DATE_EPOCH=1726676250\n             SOURCE_GIT_COMMIT=0b1616cb0c45e5fdb5792fb96ffce1f157705369\n             SOURCE_GIT_TAG=v6.0.6-23073-g0b1616cb0c\n             SOURCE_GIT_URL=https://github.com/openshift/console\nLabels:      License=GPLv2+\n             architecture=x86_64\n             build-date=2024-09-18T17:30:51\n             com.redhat.component=openshift-enterprise-console-container\n             com.redhat.license_terms=https://www.redhat.com/agreements\n             description=This is a component of OpenShift Container Platform and provides a web console.\n             distribution-scope=public\n             io.buildah.version=1.29.0\n             io.k8s.description=This is a component of OpenShift Container Platform and provides a web console.\n             io.k8s.display-name=OpenShift Console\n             io.openshift.build.commit.id=0b1616cb0c45e5fdb5792fb96ffce1f157705369\n             io.openshift.build.commit.url=https://github.com/openshift/console/commit/0b1616cb0c45e5fdb5792fb96ffce1f157705369\n             io.openshift.build.source-location=https://github.com/openshift/console\n             io.openshift.expose-services=\n             io.openshift.maintainer.component=Management Console\n             io.openshift.maintainer.project=OCPBUGS\n             io.openshift.tags=openshift,console\n             maintainer=Samuel Padgett &lt;spadgett@redhat.com&gt;\n             name=openshift/ose-console-rhel9\n             release=202409181705.p0.g0b1616c.assembly.stream.el9\n             summary=Provides the latest release of the Red Hat Extended Life Base Image.\n             url=https://access.redhat.com/containers/#/registry.access.redhat.com/openshift/ose-console-rhel9/images/v4.16.0-202409181705.p0.g0b1616c.assembly.stream.el9\n             vcs-ref=29bd3d1b3311656960d7b3a53d39f52f318a1da9\n             vcs-type=git\n             vendor=Red Hat, Inc.\n             version=v4.16.0\n</code></pre></p> <p>From the output above, we can determine the following information for this image:</p> <ul> <li>Container Name and Repository: <code>Name:   registry.redhat.io/openshift4/ose-console-rhel9@sha256:4a6ea66336fc875f84f24bf9ebfdf5b7c166eb19dd68d88ec6035392162b4c5a</code> </li> <li>Name: <code>ose-console-rhel9</code></li> <li>Repository: <code>registry.redhat.io/openshift4/ose-console-rhel9</code></li> <li>Container Architecture: <code>Arch: amd64</code> </li> <li>Container Tag: <code>release=202409181705.p0.g0b1616c.assembly.stream.el9</code></li> <li>OpenShift version: <code>version=v4.16.0</code></li> </ul> <p>Using this information, we can represent this container image with the following purl. <pre><code># Example of the container purl using name, architecture, repository and tag\n\npkg:oci/ose-console-rhel9@sha256:4a6ea66336fc875f84f24bf9ebfdf5b7c166eb19dd68d88ec6035392162b4c5a?arch=amd64&amp;repository_url=registry.redhat.io/openshift4/ose-console-rhel9&amp;tag=v4.16.0-202409181705.p0.g0b1616c.assembly.stream.el9\"\n</code></pre></p>"},{"location":"scanning-vendors/#product-identification","title":"Product Identification","text":"<p>Common Platform Enumeration (CPE) is a standardized method of describing and identifying classes of applications,  operating systems, and hardware devices present among an enterprise's computing assets.</p> <p>Red Hat uses CPEs to uniquely identify each product and version, following the CPE 2.2 schema. Detailed information about  Red Hat CPEs can be found here. </p>"},{"location":"scanning-vendors/#rpm-repositories","title":"RPM Repositories","text":"<p>Each Red Hat container images published after June 2020 include information about the repositories from which  the packages used in the container are sourced. Scanning vendors will use the repositories to identify CPEs that are  associated with the scanned image. The following sections explain different ways to identify repository information for  a container image. </p>"},{"location":"scanning-vendors/#content-manifest-json-files","title":"Content Manifest JSON files","text":"<p>Previously, content manifest JSON files were included for each layer in the container image in the <code>root/buildinfo/</code>  directory. Inside each content manifest JSON file, you'll find a <code>content_sets</code> object, which specifies the repository names that provided the packages found in the container image. </p> <p>The following examples show how to get a list of the content manifest files from within a container image. <pre><code># Example of content manifest files for rhel9/python-312 image \n$ ls /root/buildinfo/content_manifests \n\npython-312-container-1-25.json\ns2i-core-container-1-511.json\ns2i-base-container-1-530.json   \nubi9-container-9.4-1214.json\n</code></pre></p> <pre><code># Example of content manifest files for openshift4/ose-console-rhel9 image\n$ ls /root/buildinfo/content_manifests \n\nopenshift-base-rhel9-container-v4.16.0-202409032335.p0.gb45ea65.assembly.stream.el9.json\nopenshift-enterprise-base-rhel9-container-v4.16.0-202409051837.p0.gb58673a.assembly.stream.el9.json\nopenshift-enterprise-console-container-v4.16.0-202409181705.p0.g0b1616c.assembly.stream.el9.json\nrhel-els-container-9.2-483.json\n</code></pre> <p>The following examples provide a look at the content sets object within an individual manifest file. <pre><code># Example of repositories in content sets for rhel9/python-312 image \n$ cat /root/buildinfo/content_manifests/python-312-container-1-25.json\n...\n},\n\"content_sets\": [\n        \"rhel-9-for-aarch64-baseos-rpms\",\n        \"rhel-9-for-aarch64-appstream-rpms\"\n    ],\n}\n</code></pre> The two repositories identified for the rhel9/python-312 container are <code>rhel-9-for-aarch64-baseos-rpms</code> and <code>rhel-9-for-aarch64-appstream-rpms</code>.</p> <p><pre><code># Example of repositories in content sets for openshift4/ose-console-rhel9 image\n$ cat /root/buildinfo/content_manifests/openshift-enterprise-console-container-v4.16.0-202409181705.p0.g0b1616c.assembly.stream.el9.json\n\n...\n},\n\"content_sets\": [\n        \"rhel-9-for-x86_64-appstream-eus-rpms__9_DOT_2\",\n        \"rhel-9-for-x86_64-baseos-eus-rpms__9_DOT_2\"\n    ]\n}\n</code></pre> The two repositories identified for the openshift4/ose-console-rhel9 container are <code>rhel-9-for-x86_64-appstream-eus-rpms__9_DOT_2</code> and <code>rhel-9-for-x86_64-baseos-eus-rpms__9_DOT_2</code>.</p>"},{"location":"scanning-vendors/#content-sets-json-files","title":"Content Sets JSON files","text":"<p>Starting from January 2025, the content manifest files have been replaced by a single content-sets.json file available in the <code>/usr/share/buildinfo/</code> directory and the same content is copied to the legacy location <code>/root/buildinfo/content_manifests/</code>.  In some container images, access to the root directory is locked, so the <code>/root/buildinfo/</code> location will be deprecated  in the future and the main location for the content-sets.json metadata will remain in <code>/usr/share/buildinfo</code>.</p> <p>The following is an example of how to determine the repositories used from the new content sets JSON file.  <pre><code># Example of repositories in the content sets JSON \n$ cat cat /usr/share/buildinfo/content-sets.json\n\n{\n  \"metadata\": {\n    \"icm_version\": 1,\n    \"icm_spec\": \"https://raw.githubusercontent.com/containerbuildsystem/atomic-reactor/master/atomic_reactor/schemas/content_manifest.json\",\n    \"image_layer_index\": 0\n  },\n  \"from_dnf_hint\": true,\n  \"content_sets\": [\n    \"rhel-9-for-aarch64-appstream-rpms\",\n    \"rhel-9-for-aarch64-appstream-source-rpms\",\n    \"rhel-9-for-aarch64-baseos-rpms\",\n    \"rhel-9-for-aarch64-baseos-source-rpms\",\n    \"rhel-9-for-ppc64le-appstream-rpms\",\n    \"rhel-9-for-ppc64le-appstream-source-rpms\",\n    \"rhel-9-for-ppc64le-baseos-rpms\",\n    \"rhel-9-for-ppc64le-baseos-source-rpms\",\n    \"rhel-9-for-s390x-appstream-rpms\",\n    \"rhel-9-for-s390x-appstream-source-rpms\",\n    \"rhel-9-for-s390x-baseos-rpms\",\n    \"rhel-9-for-s390x-baseos-source-rpms\",\n    \"rhel-9-for-x86_64-appstream-rpms\",\n    \"rhel-9-for-x86_64-appstream-source-rpms\",\n    \"rhel-9-for-x86_64-baseos-rpms\",\n    \"rhel-9-for-x86_64-baseos-source-rpms\"\n  ]\n}\n</code></pre></p>"},{"location":"scanning-vendors/#querying-repositories-for-binary-rpms","title":"Querying Repositories for Binary RPMs","text":"<p>Although container images provide a list of repositories from which the packages in the image are sourced, vendors may also  be interested in determining the repository that provided a specific binary RPM. This can be done using the dnf database, but  dnf is not always shipped with container images.  <pre><code># Example return of repository query \n$ dnf repoquery --qf \"%{repoid}\" libgcc-11.3.1-4.3.el9.x86_64\n\nrhel-9-for-x86_64-baseos-rpms\n</code></pre></p>"},{"location":"scanning-vendors/#rpm-repository-to-cpe-mapping","title":"RPM Repository to CPE mapping","text":"<p>Red Hat maintains a JSON file to map Red Hat RPM repositories to our CPEs. Once you have identified the repositories used for the product and version by following the previous steps, you search for the repository label and determine both the set of related CPEs and the list of repository relative URLs. The repository to CPE mapping is located  here.</p> <p>The following are examples of how to determine CPEs from repositories using the repository-to-CPE JSON file. <pre><code># Example of repository to CPE mapping for rhel9/python-312 repositories\n\"rhel-9-for-aarch64-baseos-rpms\": {\n    \"cpes\": [\n        \"cpe:/o:redhat:enterprise_linux:9::baseos\"], \n    \"repo_relative_urls\": [\n        \"content/dist/rhel9/9.1/aarch64/baseos/os\", \n        \"content/dist/rhel9/9.2/aarch64/baseos/os\", \n        \"content/dist/rhel9/9.3/aarch64/baseos/os\", \n        \"content/dist/rhel9/9.4/aarch64/baseos/os\", \n        \"content/dist/rhel9/9.5/aarch64/baseos/os\", \n        \"content/dist/rhel9/9.6/aarch64/baseos/os\", \n        \"content/dist/rhel9/9.7/aarch64/baseos/os\", \n        \"content/dist/rhel9/9.8/aarch64/baseos/os\", \n        \"content/dist/rhel9/9/aarch64/baseos/os\"]\n},\n...\n\"rhel-9-for-aarch64-appstream-rpms\": {\n    \"cpes\": [\n        \"cpe:/a:redhat:enterprise_linux:9::appstream\"], \n    \"repo_relative_urls\": [\n        \"content/dist/rhel9/9.1/aarch64/appstream/os\", \n        \"content/dist/rhel9/9.2/aarch64/appstream/os\", \n        \"content/dist/rhel9/9.3/aarch64/appstream/os\", \n        \"content/dist/rhel9/9.4/aarch64/appstream/os\", \n        \"content/dist/rhel9/9.5/aarch64/appstream/os\", \n        \"content/dist/rhel9/9.6/aarch64/appstream/os\", \n        \"content/dist/rhel9/9.7/aarch64/appstream/os\", \n        \"content/dist/rhel9/9.8/aarch64/appstream/os\", \n        \"content/dist/rhel9/9/aarch64/appstream/os\"]\n},\n</code></pre> The two CPEs that we have identified for the rhel9/python-312 image are <code>cpe:/o:redhat:enterprise_linux:9::baseos</code> and  <code>cpe:/a:redhat:enterprise_linux:9::appstream</code>.</p> <p><pre><code># Example of repository to CPE mapping for openshift4/ose-console-rhel9 repositories\n\"rhel-9-for-x86_64-appstream-eus-rpms__9_DOT_2\": {\n    \"cpes\": [\n        \"cpe:/a:redhat:rhel_eus:9.2::appstream\"], \n    \"repo_relative_urls\": [\n        \"content/eus/rhel9/9.2/x86_64/appstream/os\"]\n},\n...\n\"rhel-9-for-x86_64-baseos-eus-rpms__9_DOT_2\": {\n    \"cpes\": [\n        \"cpe:/o:redhat:rhel_eus:9.2::baseos\"], \n    \"repo_relative_urls\": [\n        \"content/eus/rhel9/9.2/x86_64/baseos/os\"]\n},\n</code></pre> The two CPEs we have identified for the openshift4/ose-console-rhel9 image are <code>cpe:/a:redhat:rhel_eus:9.2::appstream\"</code>  and <code>cpe:/o:redhat:rhel_eus:9.2::baseos</code>.</p>"},{"location":"scanning-vendors/#product-and-component-matching-in-csaf-vex","title":"Product and Component Matching in CSAF-VEX","text":"<p>The Common Security Advisory Framework (CSAF) is a  standard that provides a structured, machine-readable way of representing and sharing security advisory information  across all software and hardware providers. </p> <p>Red Hat Product Security publishes CSAF files for every single Red Hat Security Advisory (RHSA) and VEX files for every  single CVE record that is associated with the Red Hat portfolio in any way.</p> <p>CSAF advisories and VEX data includes information about products, components and the relationships between the applicable products and components. Scanning vendors should identify the relevant products and components  individually and then determine the available product/component combinations. </p> <p>A detailed breakdown of the format and information included in these files can be found here.</p>"},{"location":"scanning-vendors/#product-matching-using-cpes-in-csaf-vex","title":"Product matching using CPEs in CSAF-VEX","text":"<p>CSAF advisories and VEX data represent products using a <code>product_name</code> object. The <code>product_name</code> entry will include a  <code>production_identification_helper</code> in the form of a CPE. Vendors should follow the previous steps to determine a list of  potential CPEs that can be used to match to <code>product_name</code> entries. More information about <code>product_name</code> objects can be found here.</p>"},{"location":"scanning-vendors/#cpes-in-csaf-vex","title":"CPEs in CSAF-VEX","text":"<p>CPEs in CSAF advisories and VEX data are represented slightly different based on fix status.</p> <ul> <li>Unfixed: Includes the <code>under_investigation</code>, <code>known_affected</code> and most <code>known_not_affected</code> product statuses</li> <li>Product version: Unfixed products will only include the major product version in the CPE</li> <li>Channel specifiers: Channel specifiers will not be included in CPEs (only applicable to RHEL 9 and before)</li> <li>Fixed: Includes all <code>fixed</code> product status and the occasional <code>known_not-affected</code> product statuses</li> <li>Product version:<ul> <li>RHEL 9 and before: Fixed products will include a major version for main stream products and a major and minor version for xUS streams</li> <li>RHEL 10: Fixed products will include a major and minor version for both main and xUS streams</li> </ul> </li> <li>Channel specifiers: Channel specifiers will be included for CPEs (only applicable to RHEL 9 and before)</li> </ul>"},{"location":"scanning-vendors/#cpe-matching-logic","title":"CPE Matching Logic","text":"<p>Due to the differences in CPE representation based on fix status, Red Hat recommends vendors attempt to match to CPEs using only the first 5 segments of the CPE and excluding any channel specifies. When available, it is best to use CPEs  with a direct match to the repository information gathered from the container, but there may not always be a direct match.</p> <p>If the repositories used in a container image are xUS streams, it is also necessary to check for the existence of a main stream CPEs as well, if the vulnerability is unfixed or did not release a fix to the xUS stream.</p> <p>Additionally, if the scanned container includes any container first content, scanning vendors should also check for an OpenShift CPE. </p> <p>The following are examples of the CPEs that should be used to account for matching and then the potential matches depending on  the CVE fix statuses and product streams. <pre><code># Example of CPEs that should be checked for the rhel9/python-312 image  \n\ncpe:/o:redhat:enterprise_linux:9\ncpe:/a:redhat:enterprise_linux:9\n</code></pre> Examples of potential CPE matches depending on fix statuses for the rhel9/python-312 container.</p> CPE product_id Notes cpe:/o:redhat:enterprise_linux:9 red_hat_enterprise_linux_9 CVE is unfixed cpe:/o:redhat:enterprise_linux:9::baseos BaseOS-9.5.0.Z.MAIN CVE-2020-11023 is fixed for RHEL 9 MAIN stream cpe:/a:redhat:enterprise_linux:9::appstream AppStream-9.5.0.Z.MAIN CVE-2020-11023 is fixed for RHEL 9 MAIN stream cpe:/a:redhat:enterprise_linux:9::crb CRB-9.5.0.Z.MAIN CVE-2020-11023 is fixed for RHEL 9 MAIN stream <p>For CVE-2020-11023, there are direct matches for both <code>cpe:/o:redhat:enterprise_linux:9</code> and <code>cpe:/a:redhat:enterprise_linux:9</code>,  so the <code>BaseOS-9.5.0.Z.MAIN</code>, <code>AppStream-9.5.0.Z.MAIN</code> and <code>CRB-9.5.0.Z.MAIN</code> product IDs should be used. </p> <p>For the OpenShift container, we also add OpenShift CPEs, because this container includes container first content.  Using the OpenShift version discovered earlier, vendors can format those OpenShift CPEs.  <pre><code># Example of CPEs that should be checked for the openshift4/ose-console-rhel9\n\ncpe:/o:redhat:enterprise_linux:9\ncpe:/a:redhat:rhel_eus:9.2\ncpe:/o:redhat:rhel_eus:9.2\ncpe:/a:redhat:openshift:4\ncpe:/a:redhat:openshift:4.16 \n</code></pre></p> <p>Examples of potential CPE matches depending on fix statuses for the openshift4/ose-console-rhel9 container.</p> CPE product_id Notes cpe:/o:redhat:enterprise_linux:9 red_hat_enterprise_linux_9 CVE is unfixed cpe:/o:redhat:enterprise_linux:9::baseos BaseOS-9.5.0.Z.MAIN CVE-2020-11023 is fixed for RHEL 9 MAIN stream cpe:/o:redhat:rhel_eus:9.2::baseos BaseOS-9.2.0.Z.EUS CVE-2020-11023 is fixed for RHEL 9.2 EUS cpe:/a:redhat:rhel_eus:9.2::appstream AppStream-9.2.0.Z.EUS CVE-2020-11023 is fixed for RHEL 9.2 EUS cpe:/a:redhat:rhel_eus:9.2::crb CRB-9.2.0.Z.EUS CVE-2020-11023 is fixed for RHEL 9.2 EUS cpe:/a:redhat:openshift:4 red_hat_openshift_container_platform_4 CVE is unfixed cpe:/a:redhat:openshift:4.12::el8 8Base-RHOSE-4.12 CVE-2024-24791 is fixed for OpenShift 4.12 based on RHEL 8 cpe:/a:redhat:openshift:4.12::el9 9Base-RHOSE-4.12 CVE-2024-24791 is fixed for OpenShift 4.12 based on RHEL 9 cpe:/a:redhat:openshift:4.13::el8 8Base-RHOSE-4.13 CVE-2024-24791 is fixed for OpenShift 4.13 based on RHEL 8 cpe:/a:redhat:openshift:4.13::el9 9Base-RHOSE-4.13 CVE-2024-24791 is fixed for OpenShift 4.13 based on RHEL 9 cpe:/a:redhat:openshift:4.14::el8 8Base-RHOSE-4.14 CVE-2024-24791 is fixed for OpenShift 4.14 based on RHEL 8 cpe:/a:redhat:openshift:4.14::el9 9Base-RHOSE-4.14 CVE-2024-24791 is fixed for OpenShift 4.14 based on RHEL 9 cpe:/a:redhat:openshift:4.15::el8 8Base-RHOSE-4.15 CVE-2024-24791 is fixed for OpenShift 4.15 based on RHEL 8 cpe:/a:redhat:openshift:4.15::el9 9Base-RHOSE-4.15 CVE-2024-24791 is fixed for OpenShift 4.15 based on RHEL 9 cpe:/a:redhat:openshift:4.16::el9 9Base-RHOSE-4.16 CVE-2024-24791 is fixed for OpenShift 4.16 based on RHEL 9 cpe:/a:redhat:openshift:4.17::el9 9Base-RHOSE-4.17 CVE-2024-24791 is fixed for OpenShift 4.17 based on RHEL 9 <p>For CVE-2024-24791, there is a direct match for <code>cpe:/a:redhat:openshift:4.16</code>, so the <code>9Base-RHOSE-4.16</code> product ID should  be used for any container first content. </p>"},{"location":"scanning-vendors/#component-matching-using-purls-in-csaf-vex","title":"Component matching using purls in CSAF-VEX","text":"<p>CSAF advisories and VEX data represent components using a <code>product_version</code> object. The <code>product_version</code> entry will  include a <code>production_identification_helper</code> in the form of a purl. Vendors should follow the previous steps to identify  components and then format the appropriate purls to match to <code>product_version</code> entries. More information about  <code>product_version</code> objects can be found here.</p>"},{"location":"scanning-vendors/#purls-in-csaf-vex","title":"Purls in CSAF-VEX","text":"<p>Similarly to CPEs, purls in CSAF advisories and VEX data are represented differently based on fix status.</p> <ul> <li>Unfixed: Includes the <code>under_investigation</code>, <code>known_affected</code> and most <code>known_not_affected</code> product statuses</li> <li>Component version: All unfixed components, both <code>rpm</code> and <code>oci</code> purl formats will not include any component versioning</li> <li>Architecture: SRPMs will have the qualifier <code>arch=src</code>, but both binary RPMs and container will not include any     architecture information</li> <li>Fixed: Includes all <code>fixed</code> product status and the occasional <code>known_not_affected</code> product statuses</li> <li>Component version: All fixed components will include versioning in  the <code>rpm</code> and <code>oci</code> purl formats</li> <li>Architecture: All fixed components will include architecture information in the <code>rpm</code> and <code>oci</code> purl formats</li> </ul>"},{"location":"scanning-vendors/#purl-matching-logic","title":"Purl Matching Logic","text":"<p>As seen above, purls in CSAF advisories and VEX files can be represented differently based on fix status. When attempting to match a component using purls in these files, Red Hat recommends vendors to matching to against any component entries  based on component name. </p> <p>The following are examples of the purls that could be matched depending on both the fix status and the  fix component version.</p>"},{"location":"scanning-vendors/#rpms-srpms-rpm-modules","title":"RPMs, SRPMS, RPM modules","text":"<pre><code># Example of potential purls that should be checked for libgcc component \n\npkg:rpm/redhat/libgcc \npkg:rpm/redhat/libgcc@ \n</code></pre> <p>Example of potential purl matches depending on fix status for the libgcc component, limited to the x86_64 architecture.  </p> purl product_id Notes pkg:rpm/redhat/libgcc libgcc CVE is unfixed pkg:rpm/redhat/libgcc@4.8.5-45.el7_9?arch=x86_64 libgcc-0:4.8.5-45.el7_9.x86_64 CVE-2020-11023 is fixed pkg:rpm/redhat/libgcc@4.8.5-40.el7_7?arch=x86_64 libgcc-0:4.8.5-40.el7_7.x86_64 CVE-2020-11023 is fixed pkg:rpm/redhat/libgcc@11.5.0-5.el9_5?arch=x86_64 libgcc-0:11.5.0-5.el9_5.x86_64 CVE-2020-11023 is fixed pkg:rpm/redhat/libgcc@8.4.1-1.4.el8_4?arch=x86_64 libgcc-0:8.4.1-1.4.el8_4.x86_64 CVE-2020-11023 is fixed pkg:rpm/redhat/libgcc@8.5.0-18.3.el8_8?arch=x86_64 libgcc-0:8.5.0-18.3.el8_8.x86_64 CVE-2020-11023 is fixed pkg:rpm/redhat/libgcc@8.3.1-8.el8_2?arch=x86_64 libgcc-0:8.3.1-8.el8_2.x86_64 CVE-2020-11023 is fixed pkg:rpm/redhat/libgcc@11.4.1-4.el9_4?arch=x86_64 libgcc-0:11.4.1-4.el9_4.x86_64 CVE-2020-11023 is fixed pkg:rpm/redhat/libgcc@8.5.0-23.el8_10?arch=x86_64 libgcc-0:8.5.0-23.el8_10.x86_64 CVE-2020-11023 is fixed pkg:rpm/redhat/libgcc@11.3.1-4.4.el9_2?arch=x86_64 libgcc-0:11.3.1-4.4.el9_2.x86_64 CVE-2020-11023 is fixed pkg:rpm/redhat/libgcc@8.5.0-10.4.el8_6?arch=x86_64 libgcc-0:8.5.0-10.4.el8_6.x86_64 CVE-2020-11023 is fixed pkg:rpm/redhat/libgcc@11.2.1-9.5.el9_0?arch=x86_64 libgcc-0:11.2.1-9.5.el9_0.x86_64 CVE-2020-11023 is fixed"},{"location":"scanning-vendors/#container-first-content","title":"Container first content","text":"<p><pre><code># Example of potential purls that should be checked for the ose-console-rhel9 container \n\npkg:oci/ose-console-rhel9\npkg:oci/ose-console-rhel9@\n</code></pre> Example of potential purl matches depending on fix status for the openshift4/ose-console-rhel9 container,  limited to the amd64 architecture.</p> purl proudct_id Notes pkg:oci/ose-console-rhel9 openshift4/ose-console-rhel9 CVE is unfixed pkg:oci/ose-console-rhel9@sha256:fb32b644069ea9dbd35da2895d9fe9fda94ed50fb0707121645b168c31b57bde?arch=amd64&amp;repository_url=registry.redhat.io/openshift4/ose-console-rhel9&amp;tag=v4.16.0-202410180404.p0.g95b8916.assembly.stream.el9 openshift4/ose-console-rhel9@sha256:fb32b644069ea9dbd35da2895d9fe9fda94ed50fb0707121645b168c31b57bde_amd64 CVE-2024-24791 is fixed pkg:oci/ose-console-rhel9@sha256:1b5f3e45a6778bad18ab5acbca08ee4390cd8b1fdefd2ca3020de7b127f3a54c?arch=amd64&amp;repository_url=registry.redhat.io/openshift4/ose-console-rhel9&amp;tag=v4.17.0-202410091535.p0.ge61f187.assembly.stream.el9 openshift4/ose-console-rhel9@sha256:1b5f3e45a6778bad18ab5acbca08ee4390cd8b1fdefd2ca3020de7b127f3a54c_amd64 CVE-2024-24791 is fixed"},{"location":"scanning-vendors/#using-purls-and-cpe-to-find-product-ids","title":"Using purls and CPE to find Product IDs","text":"<p>Vendors should use the previous steps to be able to identify the appropriate <code>product_name</code> objects using CPE and <code>product_version</code>  objects using purl. </p> <p>In order to determine unique <code>product_id</code> combinations for each product/component pair, vendors should use the <code>relationship</code> object. More information about how to determine unique <code>product_id</code> combinations using <code>product_name</code>, <code>product_version</code> and <code>relationships</code> can  be found here.</p> <p>For CVE-2020-11023, the following product/component IDs are available for the rhel9/python-312 container and the libgcc component, using the <code>BaseOS-9.5.0.Z.MAIN</code>, <code>AppStream-9.5.0.Z.MAIN</code> and <code>CRB-9.5.0.Z.MAIN</code> product IDs to filter out any potential purl matches for irrelevant product streams. </p> Product product_id Component product_id Product/Component product_id Notes BaseOS-9.5.0.Z.MAIN libgcc-0:11.5.0-5.el9_5.x86_64 BaseOS-9.5.0.Z.MAIN:libgcc-0:11.5.0-5.el9_5.x86_64 CVE-2020-11023 is fixed AppStream-9.5.0.Z.MAIN libgcc-0:11.5.0-5.el9_5.x86_64 AppStream-9.5.0.Z.MAIN:libgcc-0:11.5.0-5.el9_5.x86_64 CVE-2020-11023 is fixed CRB-9.5.0.Z.MAIN libgcc-0:11.5.0-5.el9_5.x86_64 CRB-9.5.0.Z.MAIN:libgcc-0:11.5.0-5.el9_5.x86_64 CVE-2020-11023 is fixed <p>For CVE-2024-24791, the following product/component ID is available for the openshift4/ose-console-rhel9 container, using the <code>9Base-RHOSE-4.16</code> product ID  value to filter out any potential purl matches for irrelevant product streams.</p> Product product_id Component product_id Product/Component product_id Notes 9Base-RHOSE-4.16 openshift4/ose-console-rhel9@sha256:fb32b644069ea9dbd35da2895d9fe9fda94ed50fb0707121645b168c31b57bde_amd64 9Base-RHOSE-4.16:openshift4/ose-console-rhel9-operator@sha256:514ab7310f840027dc2609b10fa465eb6282c11d110f3d69efcf21ea5ef63ec9_amd64 CVE-2024-24791 is fixed"},{"location":"scanning-vendors/#determine-vulnerability-information","title":"Determine Vulnerability Information","text":"<p>After following the previous steps, vendors should now have a list of unique product/component pairs in the form of  unique <code>product_id</code> combinations. These <code>product_id</code> combinations should be used to determine severity, affectedness information and any available security fixes.</p> <p>The following section will continue with CVE-2020-11023 for the rhel9/python-312 container and the libgcc component. </p>"},{"location":"scanning-vendors/#cve-information","title":"CVE Information","text":"<p>Basic CVE information is represented in the <code>vulnerabilities</code> section of CSAF advisories and VEX data:</p> <ul> <li><code>cve</code>: The official CVE ID</li> <li><code>cwe</code>: Information about the corresponding CWE, include the CWE ID and the name </li> <li><code>discovery_date</code>: The first reported date of the vulnerability</li> </ul> <pre><code>\"vulnerabilities\": [\n    {\n      \"cve\": \"CVE-2020-11023\",\n      \"cwe\": {\n        \"id\": \"CWE-79\",\n        \"name\": \"Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\"\n      },\n      \"discovery_date\": \"2020-06-23T00:00:00+00:00\",\n</code></pre>"},{"location":"scanning-vendors/#affectedness","title":"Affectedness","text":"<p>Affectedness information is also found in the <code>vulnerabilities</code>section of the document. Each product/component <code>product_id</code>  will be listed in the <code>product_status</code> category that corresponds to the affectedness of that product/component pair.</p> <p>CVEs should be reported as follows, based on the <code>product_status</code> for the product/component pair.</p> Product Status Product Details Component Details Reporting Information <code>under_investigation</code> or <code>known_affected</code> Only main product version information available No component version information available Reported <code>known_not_affected</code> Only main product version information available Component version may be available Not reported <code>fixed</code> A CPE match exists The fixed component version is newer than the component version included in the scanned software Reported: The component is vulnerable and an associated RHSA should also be reported. <code>fixed</code> A CPE match exists The fixed component version is either a direct match or older than the component version included in the scanned software Not reported: The component should be considered already fixed and is not vulnerable in the scanned software. <p>In the previous example, for CVE-2020-11023, the three product/component <code>product_id</code>s identified are listed in the <code>fixed</code>  product status. Because the libgcc-0:11.5.0-5.el9_5 component version is newer than the identified libgcc-0:11.3.1-4.3.el9  component version that was present in the rhel9/python-312 container, the package is considered vulnerable and this CVE should be reported. <pre><code>\"vulnerabilities\": [\n    {\n        ...\n        \"product_status\": {\n            \"fixed\": [\n                ... , \n                \"AppStream-9.5.0.Z.MAIN:libgcc-0:11.5.0-5.el9_5.x86_64\",\n                \"BaseOS-9.5.0.Z.MAIN:libgcc-0:11.5.0-5.el9_5.x86_64\",\n                \"CRB-9.5.0.Z.MAIN:libgcc-0:11.5.0-5.el9_5.x86_64\" \n                ...\n            ],\n        }\n    }\n]\n</code></pre></p>"},{"location":"scanning-vendors/#rhsas","title":"RHSAs","text":"<p>Remediation information is also available in the <code>vulnerabilities</code> section. Each product/component pair is also listed with <code>category</code> and <code>details</code> attributes that describe the fix status of that product and component. </p> <p>For CVE-2020-11023, the three product/component <code>product_id</code>s identified are fixed, so they are also listed in the <code>vendor_fix</code> category of the <code>remediations</code> object. The <code>url</code> field will provide the RHSA link that shipped the fixes. <pre><code>\"remediations\": [\n    ...\n    },\n    {\n        \"category\": \"vendor_fix\",\n        \"details\": \"For details on how to apply this update, which includes the changes described in this advisory, refer to:\\n\\nhttps://access.redhat.com/articles/11258\",\n        \"product_ids\": [\n            ... , \n             \"AppStream-9.5.0.Z.MAIN:libgcc-0:11.5.0-5.el9_5.x86_64\",\n             \"BaseOS-9.5.0.Z.MAIN:libgcc-0:11.5.0-5.el9_5.x86_64\",\n             \"CRB-9.5.0.Z.MAIN:libgcc-0:11.5.0-5.el9_5.x86_64\" \n            ...\n        ],\n        \"url\": \"https://access.redhat.com/errata/RHSA-2025:1346\"\n    }\n] \n</code></pre></p>"},{"location":"scanning-vendors/#cvss-score-and-severity","title":"CVSS score and Severity","text":"<p>The last sections in the <code>vulnerabilities</code> object to be aware of are the <code>scores</code> object and the <code>threats</code> object. Both CVSS scores and Red Hat severities are available when the product/component pair differs from the aggregate CVE severity. Red Hat recommends that scanning vendors check the per product CVSS scores and severity scores for each vulnerability  and report the product/component severity instead of the aggregate severity for the CVE, when applicable. </p> <p>For the rhel9/python-312 container and the libgcc component, the CVSS base score of 6.1 with a CVSS vector of  CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N. <pre><code>\"scores\": [\n    {\n        \"cvss_v3\": {\n            \"attackComplexity\": \"LOW\",\n            \"attackVector\": \"NETWORK\",\n            \"availabilityImpact\": \"NONE\",\n            \"baseScore\": 6.1,\n            \"baseSeverity\": \"MEDIUM\",\n            \"confidentialityImpact\": \"LOW\",\n            \"integrityImpact\": \"LOW\",\n            \"privilegesRequired\": \"NONE\",\n            \"scope\": \"CHANGED\",\n            \"userInteraction\": \"REQUIRED\",\n            \"vectorString\": \"CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N\",\n            \"version\": \"3.1\"\n        },\n        \"products\": [\n            ... , \n             \"AppStream-9.5.0.Z.MAIN:libgcc-0:11.5.0-5.el9_5.x86_64\",\n             \"BaseOS-9.5.0.Z.MAIN:libgcc-0:11.5.0-5.el9_5.x86_64\",\n             \"CRB-9.5.0.Z.MAIN:libgcc-0:11.5.0-5.el9_5.x86_64\" \n            ...\n        ]\n    }\n],\n</code></pre></p> <p>A Low Red Hat severity should be reported for the rhel9/python-312 container and the libgcc component. <pre><code>\"threats\": [\n    {\n        \"category\": \"impact\",\n        \"details\": \"Low\",\n          \"product_ids\": [\n             ... , \n             \"AppStream-9.5.0.Z.MAIN:libgcc-0:11.5.0-5.el9_5.x86_64\",\n             \"BaseOS-9.5.0.Z.MAIN:libgcc-0:11.5.0-5.el9_5.x86_64\",\n             \"CRB-9.5.0.Z.MAIN:libgcc-0:11.5.0-5.el9_5.x86_64\" \n             ...\n          ]\n        }\n      ],\n</code></pre></p>"},{"location":"scanning-vendors/#frequently-asked-questions-faqs","title":"Frequently Asked Questions (FAQs)","text":"<p>Vendors are encouraged to raise any questions regarding security data by opening a 'Ticket' issue type in the public SECDATA Jira project.</p> <p>Many scanning vendors face similar challenges when reading and parsing Red Hat's security data. To check if your question has already been asked, you can review the list of questions asked here.</p>"},{"location":"scanning-vendors/#python-and-venv","title":"Python and VENV","text":"<p>https://issues.redhat.com/browse/SECDATA-831</p>"},{"location":"scanning-vendors/#repository-relative-urls","title":"Repository Relative URLs","text":"<p>https://issues.redhat.com/browse/SECDATA-1089 https://issues.redhat.com/browse/SECDATA-797 https://issues.redhat.com/browse/SECDATA-1020</p>"},{"location":"scanning-vendors/#empty-content-sets","title":"Empty Content Sets","text":"<p>https://issues.redhat.com/browse/SECDATA-966</p>"},{"location":"scanning-vendors/#differences-in-oval-and-vex-cpes","title":"Differences in OVAL and VEX CPEs","text":"<p>https://issues.redhat.com/browse/SECDATA-1141</p>"},{"location":"scanning-vendors/#duplicate-rhsas","title":"Duplicate RHSAs","text":"<p>https://issues.redhat.com/browse/SECDATA-969</p>"},{"location":"scanning-vendors/#additional-questions-or-concerns","title":"Additional Questions or Concerns","text":"<p>Red Hat is committed to continually improving our security data; any future changes to the data itself or the format of  the files are tracked in the Red Hat Security Data Changelog.</p> <p>For any potential bugs identified regarding security data, please file a 'Bug' issue type in the public SECDATA Jira project.</p>"}]}